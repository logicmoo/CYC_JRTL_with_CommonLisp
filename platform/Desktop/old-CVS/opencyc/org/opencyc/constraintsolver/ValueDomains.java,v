head	1.12;
access;
symbols
	PRE_1_0:1.11;
locks; strict;
comment	@# @;


1.12
date	2006.10.21.16.49.16;	author dmiles;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.11.21.46.17;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.06.21.43.25;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.04.23.57.47;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.04.14.30.23;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.30.14.52.08;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.16.17.31.46;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.16.14.25.27;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.13.16.14.44;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.10.22.22.00;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.02.11.14.59;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.30.22.59.00;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.constraintsolver;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.inferencesupport.Binding;
import org.opencyc.inferencesupport.UnitTest;

/**
 * <tt>ValueDomains</tt> object to model the attributes and behavior of
 * value domains of variables during forward checking search for one or
 * more solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: ValueDomains.java,v 1.11 2001/09/11 21:46:17 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class ValueDomains {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = ConstraintProblem.DEFAULT_VERBOSITY;

    /**
     * Dictionary of variable --> domain value <tt>ArrayList</tt>.
     */
    protected HashMap varsDictionary = new HashMap();

    /**
     * Dictionary of dictionaries of objects used to mark domain values
     * during search.  The purpose of marking is to eliminate values from
     * the solution.  First key indexes by constraint variable, second key
     * indexes by domain value for the variable, and the object represents
     * the integer search level at which the variable domain value was marked,
     * or the boolean <tt>true</tt> during a complement operation, or <tt>null</tt>
     * if the value is unmarked.
     */
    protected HashMap domains = new HashMap();

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Constructs a new <tt>ValueDomains</tt> object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public ValueDomains(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
    }

    /**
     * Displays the variables and their value domains.
     */
    public void displayVariablesAndDomains() {
        System.out.println("Variables and value domains");
        CycList orderedVariables = new CycList(constraintProblem.variables);
        orderedVariables = orderedVariables.sort();
        for (int i = 0; i < orderedVariables.size(); i++) {
            CycVariable cycVariable = (CycVariable) orderedVariables.get(i);
            ArrayList domainValues = getDomainValues(cycVariable);
            System.out.println("  " + cycVariable + "\t" + domainValues);
        }
    }

    /**
     * Initializes the domain value marking structure.
     */
    public void initializeDomainValueMarking() {
        int nbrOfVariables = constraintProblem.variables.size();
        domains = new HashMap(nbrOfVariables);
        for (int i = 0; i < nbrOfVariables; i++) {
            CycVariable cycVariable = (CycVariable) constraintProblem.variables.get(i);
            ArrayList domainValues = getDomainValues(cycVariable);
            int nbrOfValues = domainValues.size();
            HashMap domainValueMarks = new HashMap(nbrOfValues);
            domains.put(cycVariable, domainValueMarks);
            for (int j = 0; j < nbrOfValues; j++)
                domainValueMarks.put(domainValues.get(j), null);
        }
    }

    /**
     * Returns the <tt>ArrayList</tt> of domain values for a variable.
     *
     * @@param cycVariable the variable for domain values are sought
     * @@return the <tt>ArrayList</tt> of domain values for a variable
     */
    public ArrayList getDomainValues(CycVariable cycVariable) {
        return (ArrayList) varsDictionary.get(cycVariable);
    }

    /**
     * Sets the <tt>ArrayList</tt> of domain values for a variable.
     *
     * @@param cycVariable the variable
     * @@param domainValues the <tt>ArrayList</tt> of domain values for the variable
     */
    public void setDomainValues(CycVariable cycVariable, ArrayList domainValues) {
        varsDictionary.put(cycVariable, domainValues);
    }

    /**
     * Adds an <tt>Object</tt> value to the domain for a variable.
     *
     * @@param cycVariable the variable
     * @@param value the <tt>Object</tt> value which is added to the domain for the variable
     */
    public void addDomainValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = this.getDomainValues(cycVariable);
        domainValues.add(value);
        setDomainValues(cycVariable, domainValues);
    }

    /**
     * Returns <tt>true</tt> if the variable has value in its domain.
     *
     * @@param cycVariable the variable under consideration
     * @@param value the value for comparison with the variable's value domain.
     * @@return <tt>true</tt> if the variable has value in its domain.
     */
    public boolean domainHasValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = (ArrayList) varsDictionary.get(cycVariable);
        return domainValues.contains(value);
    }

    /**
     * Removes the given value from the given variable's value domain.
     *
     * @@param cycVariable the variable under consideration
     * @@param value the <tt>Object</tt> to be removed from the variable's value domain
     */
    public void removeFromValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = (ArrayList) varsDictionary.get(cycVariable);
        domainValues.remove(value);
    }

     /**
     * Resets the entry for the variable / domain value marking.
     */
    public void unmarkDomain(CycVariable cycVariable, Object value) {
        markDomain(cycVariable, value, null);
    }

    /**
     * Marks the entry for the variable / domain value with an <tt>Integer</tt> level number,
     * or a <tt>Boolean</tt> <tt>True</tt>, or <tt>null</tt>.
     */
    public void markDomain(CycVariable cycVariable, Object value, Object level) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        domainValueMarks.put(value, level);
    }

    /**
     * Returns the number of unmarked (eligible for the solution) domain values
     * for the given variable.
     */
    public int getUnmarkedDomainSize(CycVariable cycVariable) {
        int unmarkedDomainSize = 0;
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator levels = domainValueMarks.values().iterator();
        while (true) {
            if (! levels.hasNext())
                break;
            Object level = levels.next();
            if (level == null)
                unmarkedDomainSize++;
        }
        return unmarkedDomainSize;
    }

    /**
     * Returns the <tt>ArrayList</tt> of unmarked (eligible for the solution) domain
     * values for the given variable.
     */
    public ArrayList getUnmarkedDomainValues(CycVariable cycVariable) {
        ArrayList unmarkedDomainValues = new ArrayList();
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                break;
            Object keyValue = values.next();
            Object level = domainValueMarks.get(keyValue);
            if (level == null)
                unmarkedDomainValues.add(keyValue);
        }
        return unmarkedDomainValues;
    }

    /**
     * Iterates over the domain values for the given variable, changing any
     * entries marked <tt>true</tt> to <tt>Integer</tt> level.
     *
     * @@param cycVariable the variable for domain value complementation
     * @@param newLevel the new search level for the variable's domain
     * @@param selectedBinding a variable binding for optional diagnostic display
     */
    public void complementDomainValues(CycVariable cycVariable,
                                          Integer newLevel,
                                          Binding selectedBinding) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                break;
            Object keyValue = values.next();
            Object level = domainValueMarks.get(keyValue);
            if (level == null) {
                domainValueMarks.put(keyValue, newLevel);
                if (verbosity > 2)
                    System.out.println("\n" + (new Binding(cycVariable, keyValue)) +
                                       " is ruled out by " +
                                       selectedBinding);
            }
            else if (level.equals(Boolean.TRUE))
                domainValueMarks.put(keyValue, null);
        }
    }

    /**
     * Returns <tt>true</tt> iff all the domain values of the variable have been marked
     * and thus eliminated from consideration as a solution.
     *
     * @@return <tt>true</tt> if and only if all the domain values of the variable have been marked
     * and thus eliminated from consideration as a solution
     */
    public boolean isDomainWipedOut(CycVariable cycVariable) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                return true;
            Object value = values.next();
            if (! isDomainMarked(cycVariable, value))
                return false;
        }
    }

    /**
     * Returns <tt>true</tt> iff the variable / value combination is marked
     * with any level number.
     *
     * @@return <tt>true</tt> iff the variable / value combination is marked
     * with aany level number
     */
    public boolean isDomainMarked(CycVariable cycVariable, Object value) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        return (domainValueMarks.get(value)) instanceof Integer;
    }

    /**
     * Returns <tt>true</tt> iff the variable / value combination is marked
     * with a given level number.
     *
     * @@return <tt>true</tt> iff the variable / value combination is marked
     * with a given level number
     */
    public boolean isDomainMarkedAtLevel(CycVariable cycVariable,
                                            Object value,
                                            Integer level) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Object mark = domainValueMarks.get(value);
        if (mark == null)
            return false;
        else
            return mark.equals(level);
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }
}@


1.11
log
@Constraint problems now enter the cyc api initially as queries.
@
text
@d3 8
a10 3
import org.opencyc.cycobject.*;
import org.opencyc.inferencesupport.*;
import java.util.*;
d17 1
a17 1
 * @@version $Id: ValueDomains.java,v 1.10 2001/09/06 21:43:25 stephenreed Exp $
@


1.10
log
@Completed renaming of Rule to ConstraintRule class
@
text
@d12 1
a12 1
 * @@version $Id: ValueDomains.java,v 1.9 2001/09/04 23:57:47 stephenreed Exp $
d83 1
a83 8
            if (constraintProblem.variableDomainPopulator.isPostponedHighCardinalityDomain(cycVariable)) {
                if (domainValues.size() == 0)
                    System.out.println("  " + cycVariable + "\t... unpopulated high cardinality domain");
                else
                    System.out.println("  " + cycVariable + "\t... populated high cardinality domain " + domainValues);
            }
            else
                System.out.println("  " + cycVariable + "\t" + domainValues);
d190 1
a190 7
        // Special case for high cardinality domains whose complete extent may not yet
        // be known.
        if (unmarkedDomainSize == 0 &&
            constraintProblem.variableDomainPopulator.isPostponedHighCardinalityDomain(cycVariable))
            return constraintProblem.variableDomainPopulator.getDomainSize(cycVariable);
        else
            return unmarkedDomainSize;
@


1.9
log
@Continued refactoring domain population methods.
@
text
@d4 1
d12 1
a12 1
 * @@version $Id: ValueDomains.java,v 1.8 2001/09/04 14:30:23 stephenreed Exp $
@


1.8
log
@Renamed HighCardinalityDomains to VariableDomainPopulator, in preparation
for a reworking of the variable domain population technique.  The previous
idea of augmenting the constraint problem with the constraint problem argument
constraints is not efficient in a few cases where most of the rules involve
high cardinality situations.

The new technique will determine the best rule to instantiate domains for each
variable, and whether to perform the instantiation immediately, or to postpone it
for the forward checking search.  A new api call was added to get the instantiation
counts from the OpenCyc indexing mechanism.
@
text
@d11 1
a11 1
 * @@version $Id: ValueDomains.java,v 1.7 2001/08/30 14:52:08 stephenreed Exp $
d82 1
a82 1
            if (constraintProblem.variableDomainPopulator.contains(cycVariable)) {
d199 1
a199 1
            constraintProblem.variableDomainPopulator.contains(cycVariable))
@


1.7
log
@Abbreviated diagnostic output for deep backchain examination.
@
text
@d11 1
a11 1
 * @@version $Id: ValueDomains.java,v 1.6 2001/08/16 17:31:46 stephenreed Exp $
d40 1
a40 1
    protected int verbosity = 9;
d82 1
a82 1
            if (constraintProblem.highCardinalityDomains.contains(cycVariable)) {
d199 2
a200 2
            constraintProblem.highCardinalityDomains.contains(cycVariable))
            return constraintProblem.highCardinalityDomains.getDomainSize(cycVariable);
@


1.6
log
@Completed European Cathedrals use case accessing OpenCyc.
@
text
@d11 1
a11 1
 * @@version $Id: ValueDomains.java,v 1.5 2001/08/16 14:25:27 stephenreed Exp $
d76 1
a76 1
        System.out.println("\nVariables and value domains\n");
@


1.5
log
@Changed toString method of CycVariable to include "?" prefix.
Continued with unit test of the European Cathedrals constraint use case with OpenCyc connection.
@
text
@d11 1
a11 1
 * @@version $Id: ValueDomains.java,v 1.4 2001/08/13 16:14:44 stephenreed Exp $
d81 9
a89 1
            System.out.println("  " + cycVariable + "\t" + getDomainValues(cycVariable));
@


1.4
log
@Revised copyright notice to Cycorp Inc.
@
text
@d1 303
a303 304
package org.opencyc.constraintsolver;

import org.opencyc.cycobject.*;
import java.util.*;

/**
 * <tt>ValueDomains</tt> object to model the attributes and behavior of
 * value domains of variables during forward checking search for one or
 * more solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: ValueDomains.java,v 1.2 2001/08/02 11:14:59 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class ValueDomains {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = 9;

    /**
     * Dictionary of variable --> domain value <tt>ArrayList</tt>.
     */
    protected HashMap varsDictionary = new HashMap();

    /**
     * Dictionary of dictionaries of objects used to mark domain values
     * during search.  The purpose of marking is to eliminate values from
     * the solution.  First key indexes by constraint variable, second key
     * indexes by domain value for the variable, and the object represents
     * the integer search level at which the variable domain value was marked,
     * or the boolean <tt>true</tt> during a complement operation, or <tt>null</tt>
     * if the value is unmarked.
     */
    protected HashMap domains = new HashMap();

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Constructs a new <tt>ValueDomains</tt> object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public ValueDomains(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
    }

    /**
     * Displays the variables and their value domains.
     */
    public void displayVariablesAndDomains() {
        System.out.println("\nVariables and value domains\n");
        CycList orderedVariables = new CycList(constraintProblem.variables);
        orderedVariables = orderedVariables.sort();
        for (int i = 0; i < orderedVariables.size(); i++) {
            CycVariable cycVariable = (CycVariable) orderedVariables.get(i);
            System.out.println("  " + cycVariable + "\t" + getDomainValues(cycVariable));
        }
    }

    /**
     * Initializes the domain value marking structure.
     */
    public void initializeDomainValueMarking() {
        int nbrOfVariables = constraintProblem.variables.size();
        domains = new HashMap(nbrOfVariables);
        for (int i = 0; i < nbrOfVariables; i++) {
            CycVariable cycVariable = (CycVariable) constraintProblem.variables.get(i);
            ArrayList domainValues = getDomainValues(cycVariable);
            int nbrOfValues = domainValues.size();
            HashMap domainValueMarks = new HashMap(nbrOfValues);
            domains.put(cycVariable, domainValueMarks);
            for (int j = 0; j < nbrOfValues; j++)
                domainValueMarks.put(domainValues.get(j), null);
        }
    }

    /**
     * Returns the <tt>ArrayList</tt> of domain values for a variable.
     *
     * @@param cycVariable the variable for domain values are sought
     * @@return the <tt>ArrayList</tt> of domain values for a variable
     */
    public ArrayList getDomainValues(CycVariable cycVariable) {
        return (ArrayList) varsDictionary.get(cycVariable);
    }

    /**
     * Sets the <tt>ArrayList</tt> of domain values for a variable.
     *
     * @@param cycVariable the variable
     * @@param domainValues the <tt>ArrayList</tt> of domain values for the variable
     */
    public void setDomainValues(CycVariable cycVariable, ArrayList domainValues) {
        varsDictionary.put(cycVariable, domainValues);
    }

    /**
     * Adds an <tt>Object</tt> value to the domain for a variable.
     *
     * @@param cycVariable the variable
     * @@param value the <tt>Object</tt> value which is added to the domain for the variable
     */
    public void addDomainValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = this.getDomainValues(cycVariable);
        domainValues.add(value);
        setDomainValues(cycVariable, domainValues);
    }

    /**
     * Returns <tt>true</tt> if the variable has value in its domain.
     *
     * @@param cycVariable the variable under consideration
     * @@param value the value for comparison with the variable's value domain.
     * @@return <tt>true</tt> if the variable has value in its domain.
     */
    public boolean domainHasValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = (ArrayList) varsDictionary.get(cycVariable);
        return domainValues.contains(value);
    }

    /**
     * Removes the given value from the given variable's value domain.
     *
     * @@param cycVariable the variable under consideration
     * @@param value the <tt>Object</tt> to be removed from the variable's value domain
     */
    public void removeFromValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = (ArrayList) varsDictionary.get(cycVariable);
        domainValues.remove(value);
    }

     /**
     * Resets the entry for the variable / domain value marking.
     */
    public void unmarkDomain(CycVariable cycVariable, Object value) {
        markDomain(cycVariable, value, null);
    }

    /**
     * Marks the entry for the variable / domain value with an <tt>Integer</tt> level number,
     * or a <tt>Boolean</tt> <tt>True</tt>, or <tt>null</tt>.
     */
    public void markDomain(CycVariable cycVariable, Object value, Object level) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        domainValueMarks.put(value, level);
    }

    /**
     * Returns the number of unmarked (eligible for the solution) domain values
     * for the given variable.
     */
    public int getUnmarkedDomainSize(CycVariable cycVariable) {
        int unmarkedDomainSize = 0;
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator levels = domainValueMarks.values().iterator();
        while (true) {
            if (! levels.hasNext())
                break;
            Object level = levels.next();
            if (level == null)
                unmarkedDomainSize++;
        }
        // Special case for high cardinality domains whose complete extent may not yet
        // be known.
        if (unmarkedDomainSize == 0 &&
            constraintProblem.highCardinalityDomains.contains(cycVariable))
            return constraintProblem.highCardinalityDomains.getDomainSize(cycVariable);
        else
            return unmarkedDomainSize;
    }

    /**
     * Returns the <tt>ArrayList</tt> of unmarked (eligible for the solution) domain
     * values for the given variable.
     */
    public ArrayList getUnmarkedDomainValues(CycVariable cycVariable) {
        ArrayList unmarkedDomainValues = new ArrayList();
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                break;
            Object keyValue = values.next();
            Object level = domainValueMarks.get(keyValue);
            if (level == null)
                unmarkedDomainValues.add(keyValue);
        }
        return unmarkedDomainValues;
    }

    /**
     * Iterates over the domain values for the given variable, changing any
     * entries marked <tt>true</tt> to <tt>Integer</tt> level.
     *
     * @@param cycVariable the variable for domain value complementation
     * @@param newLevel the new search level for the variable's domain
     * @@param selectedBinding a variable binding for optional diagnostic display
     */
    public void complementDomainValues(CycVariable cycVariable,
                                          Integer newLevel,
                                          Binding selectedBinding) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                break;
            Object keyValue = values.next();
            Object level = domainValueMarks.get(keyValue);
            if (level == null) {
                domainValueMarks.put(keyValue, newLevel);
                if (verbosity > 2)
                    System.out.println("\n" + (new Binding(cycVariable, keyValue)) +
                                       " is ruled out by " +
                                       selectedBinding);
            }
            else if (level.equals(Boolean.TRUE))
                domainValueMarks.put(keyValue, null);
        }
    }

    /**
     * Returns <tt>true</tt> iff all the domain values of the variable have been marked
     * and thus eliminated from consideration as a solution.
     *
     * @@return <tt>true</tt> if and only if all the domain values of the variable have been marked
     * and thus eliminated from consideration as a solution
     */
    public boolean isDomainWipedOut(CycVariable cycVariable) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                return true;
            Object value = values.next();
            if (! isDomainMarked(cycVariable, value))
                return false;
        }
    }

    /**
     * Returns <tt>true</tt> iff the variable / value combination is marked
     * with any level number.
     *
     * @@return <tt>true</tt> iff the variable / value combination is marked
     * with aany level number
     */
    public boolean isDomainMarked(CycVariable cycVariable, Object value) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        return (domainValueMarks.get(value)) instanceof Integer;
    }

    /**
     * Returns <tt>true</tt> iff the variable / value combination is marked
     * with a given level number.
     *
     * @@return <tt>true</tt> iff the variable / value combination is marked
     * with a given level number
     */
    public boolean isDomainMarkedAtLevel(CycVariable cycVariable,
                                            Object value,
                                            Integer level) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Object mark = domainValueMarks.get(value);
        if (mark == null)
            return false;
        else
            return mark.equals(level);
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

@


1.3
log
@Completed coding and unit test of standalone constraint solver.
Calls to OpenCyc are yet to be included.
Unit test demonstrates solution of the Zebra puzzle in CycL form.
@
text
@d14 1
a14 1
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
d75 1
a75 1
    protected void displayVariablesAndDomains() {
d88 1
a88 1
    protected void initializeDomainValueMarking() {
d108 1
a108 1
    protected ArrayList getDomainValues(CycVariable cycVariable) {
d118 1
a118 1
    protected void setDomainValues(CycVariable cycVariable, ArrayList domainValues) {
d128 1
a128 1
    protected void addDomainValue(CycVariable cycVariable, Object value) {
d141 1
a141 1
    protected boolean domainHasValue(CycVariable cycVariable, Object value) {
d152 1
a152 1
    protected void removeFromValue(CycVariable cycVariable, Object value) {
d160 1
a160 1
    protected void unmarkDomain(CycVariable cycVariable, Object value) {
d168 1
a168 1
    protected void markDomain(CycVariable cycVariable, Object value, Object level) {
d177 1
a177 1
    protected int getUnmarkedDomainSize(CycVariable cycVariable) {
d201 1
a201 1
    protected ArrayList getUnmarkedDomainValues(CycVariable cycVariable) {
d224 1
a224 1
    protected void complementDomainValues(CycVariable cycVariable,
d253 1
a253 1
    protected boolean isDomainWipedOut(CycVariable cycVariable) {
d272 1
a272 1
    protected boolean isDomainMarked(CycVariable cycVariable, Object value) {
d284 1
a284 1
    protected boolean isDomainMarkedAtLevel(CycVariable cycVariable,
d301 1
a301 1
    protected void setVerbosity(int verbosity) {
@


1.2
log
@Continued coding methods in ForwardCheckingSearcher.  Removed search from unit tests until done.
@
text
@d1 304
a304 288
package org.opencyc.constraintsolver;

import org.opencyc.cycobject.*;
import java.util.*;

/**
 * <tt>ValueDomains</tt> object to model the attributes and behavior of
 * value domains of variables during forward checking search for one or
 * more solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: ValueDomains.java,v 1.1 2001/07/30 22:59:00 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class ValueDomains {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = 9;

    /**
     * Dictionary of variable --> domain value <tt>ArrayList</tt>.
     */
    protected HashMap varsDictionary = new HashMap();

    /**
     * Dictionary of dictionaries of objects used to mark domain values
     * during search.  The purpose of marking is to eliminate values from
     * the solution.  First key indexes by constraint variable, second key
     * indexes by domain value for the variable, and the object represents
     * the integer search level at which the variable domain value was marked,
     * or the boolean <tt>true</tt> during a complement operation, or <tt>null</tt>
     * if the value is unmarked.
     */
    protected HashMap domains = new HashMap();

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Constructs a new <tt>ValueDomains</tt> object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public ValueDomains(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
    }

    /**
     * Displays the variables and their value domains.
     */
    protected void displayVariablesAndDomains() {
        System.out.println("\nVariables and value domains\n");
        CycList orderedVariables = new CycList(constraintProblem.variables);
        orderedVariables = orderedVariables.sort();
        for (int i = 0; i < orderedVariables.size(); i++) {
            CycVariable cycVariable = (CycVariable) orderedVariables.get(i);
            System.out.println("  " + cycVariable + "\t" + getDomainValues(cycVariable));
        }
    }

    /**
     * Initializes the domain value marking structure.
     */
    protected void initializeDomainValueMarking() {
        int nbrOfVariables = constraintProblem.variables.size();
        domains = new HashMap(nbrOfVariables);
        for (int i = 0; i < nbrOfVariables; i++) {
            CycVariable cycVariable = (CycVariable) constraintProblem.variables.get(i);
            ArrayList domainValues = getDomainValues(cycVariable);
            int nbrOfValues = domainValues.size();
            HashMap domainValueMarks = new HashMap(nbrOfValues);
            domains.put(cycVariable, domainValueMarks);
            for (int j = 0; j < nbrOfValues; j++)
                domainValueMarks.put(domainValues.get(j), null);
        }
    }

    /**
     * Returns the <tt>ArrayList</tt> of domain values for a variable.
     *
     * @@param cycVariable the variable for domain values are sought
     * @@return the <tt>ArrayList</tt> of domain values for a variable
     */
    protected ArrayList getDomainValues(CycVariable cycVariable) {
        return (ArrayList) varsDictionary.get(cycVariable);
    }

    /**
     * Sets the <tt>ArrayList</tt> of domain values for a variable.
     *
     * @@param cycVariable the variable
     * @@param domainValues the <tt>ArrayList</tt> of domain values for the variable
     */
    protected void setDomainValues(CycVariable cycVariable, ArrayList domainValues) {
        varsDictionary.put(cycVariable, domainValues);
    }

    /**
     * Returns <tt>true</tt> if the variable has value in its domain.
     *
     * @@param cycVariable the variable under consideration
     * @@param value the value for comparison with the variable's value domain.
     * @@return <tt>true</tt> if the variable has value in its domain.
     */
    protected boolean domainHasValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = (ArrayList) varsDictionary.get(cycVariable);
        return domainValues.contains(value);
    }

    /**
     * Removes the given value from the given variable's value domain.
     *
     * @@param cycVariable the variable under consideration
     * @@param value the <tt>Object</tt> to be removed from the variable's value domain
     */
    protected void removeFromValue(CycVariable cycVariable, Object value) {
        ArrayList domainValues = (ArrayList) varsDictionary.get(cycVariable);
        domainValues.remove(value);
    }

     /**
     * Resets the entry for the variable / domain value marking.
     */
    protected void unmarkDomain(CycVariable cycVariable, Object value) {
        markDomain(cycVariable, value, null);
    }

    /**
     * Marks the entry for the variable / domain value with an <tt>Integer</tt> level number,
     * or a <tt>Boolean</tt> <tt>True</tt>, or <tt>null</tt>.
     */
    protected void markDomain(CycVariable cycVariable, Object value, Object level) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        domainValueMarks.put(value, level);
    }

    /**
     * Returns the number of unmarked (eligible for the solution) domain values
     * for the given variable.
     */
    protected int getUnmarkedDomainSize(CycVariable cycVariable) {
        int unmarkedDomainSize = 0;
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator levels = domainValueMarks.values().iterator();
        while (true) {
            if (! levels.hasNext())
                break;
            Object level = levels.next();
            if (level == null)
                unmarkedDomainSize++;
        }
        // Special case for high cardinality domains whose complete extent may not yet
        // be known.
        if (unmarkedDomainSize == 0 &&
            constraintProblem.highCardinalityDomains.contains(cycVariable))
            return constraintProblem.highCardinalityDomains.getDomainSize(cycVariable);
        else
            return unmarkedDomainSize;
    }

    /**
     * Returns the <tt>ArrayList</tt> of unmarked (eligible for the solution) domain
     * values for the given variable.
     */
    protected ArrayList getUnmarkedDomainValues(CycVariable cycVariable) {
        ArrayList unmarkedDomainValues = new ArrayList();
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                break;
            Object keyValue = values.next();
            Object level = domainValueMarks.get(keyValue);
            if (level != null)
                unmarkedDomainValues.add(keyValue);
        }
        return unmarkedDomainValues;
    }

    /**
     * Iterates over the domain values for the given variable, changing any
     * entries marked <tt>true</tt> to <tt>Integer</tt> level.
     *
     * @@param cycVariable the variable for domain value complementation
     * @@param newLevel the new search level for the variable's domain
     * @@param selectedBinding a variable binding for optional diagnostic display
     */
    protected void complementDomainValues(CycVariable cycVariable,
                                          Integer newLevel,
                                          Binding selectedBinding) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                break;
            Object keyValue = values.next();
            Object level = domainValueMarks.get(keyValue);
            if (level == null) {
                domainValueMarks.put(keyValue, newLevel);
                if (verbosity > 2)
                    System.out.println("\n" + (new Binding(cycVariable, keyValue)) +
                                       " is ruled out by " +
                                       selectedBinding);
            }
            else if (level.equals(Boolean.TRUE))
                domainValueMarks.put(keyValue, null);
        }
    }

    /**
     * Returns <tt>true</tt> iff all the domain values of the variable have been marked
     * and thus eliminated from consideration as a solution.
     *
     * @@return <tt>true</tt> if and only if all the domain values of the variable have been marked
     * and thus eliminated from consideration as a solution
     */
    protected boolean isDomainWipedOut(CycVariable cycVariable) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        Iterator values = domainValueMarks.keySet().iterator();
        while (true) {
            if (! values.hasNext())
                return true;
            Object value = values.next();
            if (! isDomainMarked(cycVariable, value))
                return false;
        }
    }

    /**
     * Returns <tt>true</tt> iff the variable / value combination is marked
     * with any level number.
     *
     * @@return <tt>true</tt> iff the variable / value combination is marked
     * with aany level number
     */
    protected boolean isDomainMarked(CycVariable cycVariable, Object value) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        return (domainValueMarks.get(value)) instanceof Integer;
    }

    /**
     * Returns <tt>true</tt> iff the variable / value combination is marked
     * with a given level number.
     *
     * @@return <tt>true</tt> iff the variable / value combination is marked
     * with a given level number
     */
    protected boolean isDomainMarkedAtLevel(CycVariable cycVariable,
                                            Object value,
                                            Integer level) {
        HashMap domainValueMarks = (HashMap) domains.get(cycVariable);
        return (domainValueMarks.get(value)).equals(level);
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    protected void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

@


1.1
log
@Refactored ConstraintProblem class and added several other supporting classes
@
text
@d11 1
a11 1
 * @@version $Id$
d186 2
a187 2
     * Returns the <tt>ArrayList</tt> of unmarked (eligible for the solution) domain values
     * for the given variable.
@

