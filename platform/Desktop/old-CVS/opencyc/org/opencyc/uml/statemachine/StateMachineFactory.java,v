head	1.17;
access;
symbols
	PRE_1_0:1.17;
locks; strict;
comment	@# @;


1.17
date	2003.02.24.22.41.34;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.09.02.14.19;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.07.03.37.04;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.06.02.57.03;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.09.00.00.26;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.14.22.06.05;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.09.15.19.10;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.06.16.35.28;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.06.00.24.35;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.04.21.38.26;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.04.16.23.23;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.04.02.33.48;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.04.02.21.04;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.03.22.19.30;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.01.23.40.27;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.01.23.24.07;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.01.16.18.53;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Passing unit tests for State Machine Interpretation
@
text
@package org.opencyc.uml.statemachine;

import java.util.*;
import org.opencyc.cycobject.*;
import org.opencyc.uml.core.*;
import org.opencyc.uml.commonbehavior.*;
import org.opencyc.uml.action.*;
import org.opencyc.uml.datatypes.Multiplicity;

/**
 * StateVertex from the UML State_Machines package.
 *
 * @@version $Id: StateMachineFactory.java,v 1.16 2003/02/09 02:14:19 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class StateMachineFactory {

    /**
     * the namespace for this state machine and its components
     */
    protected Namespace namespace;

    /**
     * the state machine being assembled
     */
    protected StateMachine stateMachine;

    /**
     * Constructs a new StateMachineFactory object.
     */
    public StateMachineFactory() {
    }

    /**
     * Makes a new state machine object.  All further objects defined for this state
     * machine will linked to the given namespace.  The name of the state machine is
     * also required to be the name of the context classifier
     *
     * @@param namespaceName the state machine namespace name
     * @@param name the identifier for the state machine within its containing
     * namespace
     * @@param commentString the comment for this state machine
     * @@param contextGeneralizations the list of Classifer generalizations for the
     * given context classifier
     * @@return the new state machine object
     */
    public StateMachine makeStateMachine(String namespaceName,
                                         String name,
                                         String commentString) {
        stateMachine = new StateMachine();
        namespace = new Namespace(namespaceName);
        setNamespaceNameComment(stateMachine,
                                name,
                                commentString);
        return stateMachine;
    }

    /**
     * Associates the given Classifier shell with the state machine.
     *
     * @@param name the name of the context Classifier
     * @@param commentString the comment for the given context Classifier
     */
    public void associateClassifierToStateMachine (String name,
                                                   String commentString) {
        org.opencyc.uml.core.Class context = new org.opencyc.uml.core.Class();
        setNamespaceNameComment(context,
                                name,
                                commentString);
        context.setIsAbstract(false);
        stateMachine.setContext(context);
    }

    /**
     * Adds a direct super classifer to the context Classifier.
     *
     * @@param generalizableElement the direct super Classifier
     */
    public void addGeneralizationToClassifier (Classifier generalizableElement) {
        stateMachine.getContext().addGeneralization(generalizableElement);
    }

    /**
     * Adds a state variable to the context Classifier.
     *
     * @@param name the name of the state variable
     * @@param commentString the comment for this state machine
     * @@param targetScope indicates whether this is a class or instance attribute
     * @@param type the type of the state variable
     * @@param changeability indicates whether the attribute may be changed
     * @@param multiplicity the multiplicity of the attribute
     * @@param ordering the ordering of the attribute
     * @@param initialValue the initial value expression
     */
    public StateVariable addStateVariableToClassifier (String name,
                                                       String commentString,
                                                       int targetScope,
                                                       Object type,
                                                       int changeability,
                                                       Multiplicity multiplicity,
                                                       int ordering,
                                                       Expression initialValue) {
        StateVariable stateVariable = new StateVariable();
        setNamespaceNameComment(stateVariable,
                                name,
                                commentString);
        stateVariable.setType(type);
        stateVariable.setChangeability(changeability);
        stateVariable.setMultiplicity(multiplicity);
        stateVariable.setOrdering(ordering);
        stateVariable.setInitialValue(initialValue);
        stateVariable.setTargetScope(targetScope);
        stateMachine.getContext().addFeature(stateVariable);
        return stateVariable;
    }

    /**
     * Makes a new procedure object.
     *
     * @@param name the identifier for the procedure within its containing
     * namespace
     * @@param commentString the comment for this procedure
     * @@param language the name of the language in which the body attribute is written
     * @@param body the text of the procedure written in the given language
     * @@param isList true when the arguments to the procedure are passed as
     * attributes of a single object, or false when passed separately
     * @@param expression the text of the procedure written in the given language
     * @@param method a method which is performed by the procedure
     * @@return the new procedure object
     */
    public Procedure makeProcedure (String name,
                                    String commentString,
                                    String language,
                                    Object body,
                                    boolean isList) {
        Procedure procedure = new Procedure();
        setNamespaceNameComment(procedure,
                                name,
                                commentString);
        procedure.setLanguage(language);
        procedure.setBody(body);
        procedure.setIsList(isList);
        return procedure;
    }

    /**
     * Adds an input pin (variable) to the given procedure.
     *
     * @@param inputPin the given input pin shell
     * @@param name the name of the input pin (variable)
     * @@param commentString the comment for this input pin
     * @@param procedure the given procedure to which the input pin is to
     * be added
     * @@param type the Class of the input pin (variable)
     */
    public void addInputPinToProcedure(InputPin inputPin,
                                       String name,
                                       String commentString,
                                       Procedure procedure,
                                       java.lang.Class type) {
        setNamespaceNameComment(inputPin,
                                name,
                                commentString);
        inputPin.setType(type);
        inputPin.setProcedure(procedure);
        procedure.getArgument().add(inputPin);
    }

    /**
     * Adds an output pin (variable) to the given procedure.
     *
     * @@param outputPin the given input pin shell
     * @@param name the name of the output pin (variable)
     * @@param commentString the comment for this output pin
     * @@param procedure the given procedure to which the output pin is to
     * be added
     * @@param type the Class of the output pin (variable)
     */
    public void addOutputPinToProcedure(OutputPin outputPin,
                                        String name,
                                        String commentString,
                                        Procedure procedure,
                                        java.lang.Class type) {
        setNamespaceNameComment(outputPin,
                                name,
                                commentString);
        outputPin.setType(type);
        outputPin.setProcedure(procedure);
        procedure.getResult().add(outputPin);
    }

    /**
     * Makes a new Event object.
     *
     * @@param name the identifier for the event within its containing
     * namespace
     * @@param commentString the comment for this event
     * @@return the new event object
     */
    public Event makeEvent (String name,
                            String commentString) {
        Event event = new Event();
        setNamespaceNameComment(event,
                                name,
                                commentString);
        return event;
    }

    /**
     * Makes a new CallEvent object.
     *
     * @@param name the identifier for the call event within its containing
     * namespace
     * @@param commentString the comment for this call event
     * @@param specification the specification of the operation called by this event
     * @@return the new call event object
     */
    public CallEvent makeCallEvent (String name,
                                    String commentString,
                                    String specification) {
        CallEvent callEvent = new CallEvent();
        setNamespaceNameComment(callEvent,
                                name,
                                commentString);
        Operation operation = new Operation();
        setNamespaceNameComment(operation,
                                name,
                                commentString);
        operation.setSpecification(specification);
        callEvent.setOperation(operation);
        return callEvent;
    }

    /**
     * Makes a new ChangeEvent object.
     *
     * @@param name the identifier for the change event within its containing
     * namespace
     * @@param commentString the comment for this change event
     * @@param language the language of the boolean change expression
     * @@param body the body of the boolean change expression
     * @@return the new change event object
     */
    public ChangeEvent makeChangeEvent (String name,
                                        String commentString,
                                        String language,
                                        Object body) {
        ChangeEvent changeEvent = new ChangeEvent();
        setNamespaceNameComment(changeEvent,
                                name,
                                commentString);
        BooleanExpression changeExpression = new BooleanExpression();
        changeExpression.setLanguage(language);
        changeExpression.setBody(body);
        changeEvent.setChangeExpression(changeExpression);
        return changeEvent;
    }

    /**
     * Makes a new CompletionEvent object.
     *
     * @@param name the identifier for the completion event within its containing
     * namespace
     * @@param commentString the comment for this completion event
     * @@param state the state issuing this completion expression
     * @@return the new completion event object
     */
    public CompletionEvent makeCompletionEvent (String name,
                                                String commentString,
                                                State state) {
        CompletionEvent completionEvent = new CompletionEvent(state);
        setNamespaceNameComment(completionEvent,
                                name,
                                commentString);
        return completionEvent;
    }

    /**
     * Makes a new SignalEvent object.
     *
     * @@param name the identifier for the signal event within its containing
     * namespace
     * @@param commentString the comment for this signal event
     * @@param signal the signal causing this event
     * @@return the new signal event object
     */
    public SignalEvent makeSignalEvent (String name,
                                        String commentString,
                                        Signal signal) {
        SignalEvent signalEvent = new SignalEvent();
        setNamespaceNameComment(signalEvent,
                                name,
                                commentString);
        signalEvent.setSignal(signal);
        return signalEvent;
    }

    /**
     * Makes a new TimeEvent object.
     *
     * @@param name the identifier for the change event within its containing
     * namespace
     * @@param commentString the comment for this change event
     * @@param language the language of the boolean change expression
     * @@param body the body of the boolean change expression
     * @@return the new change event object
     */
    public TimeEvent makeTimeEvent (String name,
                                    String commentString,
                                    String language,
                                    Object body) {
        TimeEvent timeEvent = new TimeEvent();
        setNamespaceNameComment(timeEvent,
                                name,
                                commentString);
        TimeExpression when = new TimeExpression();
        when.setLanguage(language);
        when.setBody(body);
        timeEvent.setWhen(when);
        return timeEvent;
    }


    /**
     * Adds a parameter to the given event.
     *
     * @@param name the name of parameter
     * @@param commentString the comment for this parameter
     * @@param event the given event to which the parameter is to
     * be added
     * @@param type the Class of the parameter
     * @@return the adeded parameter for the given event
     */
    public Parameter addParameterToEvent(String name,
                                         String commentString,
                                         Event event,
                                         java.lang.Class type) {
        Parameter parameter = new Parameter();
        setNamespaceNameComment(parameter,
                                name,
                                commentString);
        if (event instanceof CallEvent)
            parameter.setBehavioralFeature(((CallEvent) event).getOperation());
        parameter.setType(type);
        return parameter;
    }

    /**
     * Destroys the given event, its parameters and its comment by unlinking
     * them from their associations.
     *
     * @@param event the given event to be destroyed
     */
    public void destroyEvent (Event event) {
        Comment comment = event.getComment();
        Namespace namespace = comment.getNamespace();
        namespace.getOwnedElement().remove(comment);
        Iterator parameters = event.getParameter().iterator();
        while (parameters.hasNext())
            destroyParameter((Parameter) parameters.next());
        namespace.getOwnedElement().remove(event);
        event.setComment(null);
        event.setNamespace(null);
    }

    /**
     * Destroys the given comment by unlinking it from its associations.
     *
     * @@param comment the given comment to destroy
     */
    public void destroyComment (Comment comment) {
        Namespace namespace = comment.getNamespace();
        namespace.getOwnedElement().remove(comment);
        comment.setComment(null);
        comment.setNamespace(null);
        comment.setAnnotatedElement(null);
    }

    /**
     * Destroys the given parameter by unlinking it from its associations.
     *
     * @@param parameter the given parameter to destroy
     */
    public void destroyParameter (Parameter parameter) {
        destroyComment(parameter.getComment());
        Namespace namespace = parameter.getNamespace();
        namespace.getOwnedElement().remove(parameter);
        parameter.setComment(null);
        parameter.setNamespace(null);
        parameter.setBehavioralFeature(null);
        parameter.setDefaultValue(null);
    }

    /**
     * Makes a new simple state object.  The top (composite) state must be created
     * first, then parent states should be created before their child simple states.
     *
     * @@param name the identifier for the simple state within its containing
     * namespace
     * @@param commentString the comment for this simple state
     * @@param container the container (parent) of this simple state, or null if top state
     * @@param entry the entry action for this simple state, or null if none
     * @@param exit the exit action for this simple state, or null if none
     * @@param doActivity the do activity for this simple state, or null if none
     * @@return the newsimple  state object
     */
    public SimpleState makeSimpleState (String name,
                                        String commentString,
                                        CompositeState container,
                                        Procedure entry,
                                        Procedure exit,
                                        Procedure doActivity) {
        SimpleState simpleState = new SimpleState();
        setNamespaceNameComment(simpleState,
                                name,
                                commentString);
        simpleState.setContainer(container);
        if (container == null)
            simpleState.setStateMachine(stateMachine);
        else
            container.getSubVertex().add(simpleState);
        simpleState.setEntry(entry);
        simpleState.setExit(exit);
        simpleState.setDoActivity(doActivity);
        return simpleState;
    }

    /**
     * Makes a new final state object.  The top (composite) state must be created
     * first, then parent states should be created before their child final states.
     *
     * @@param name the identifier for the final state within its containing
     * namespace
     * @@param commentString the comment for this final state
     * @@param container the container (parent) of this final state, or null if top state
     * @@param entry the entry action for this final state, or null if none
     * @@param exit the exit action for this final state, or null if none
     * @@param doActivity the do activity for this final state, or null if none
     * @@return the newfinal  state object
     */
    public FinalState makeFinalState (String name,
                                      String commentString,
                                      CompositeState container,
                                      Procedure entry,
                                      Procedure exit,
                                      Procedure doActivity) {
        FinalState finalState = new FinalState();
        setNamespaceNameComment(finalState,
                                name,
                                commentString);
        finalState.setContainer(container);
        if (container == null)
            finalState.setStateMachine(stateMachine);
        else
            container.getSubVertex().add(finalState);
        finalState.setEntry(entry);
        finalState.setExit(exit);
        finalState.setDoActivity(doActivity);
        return finalState;
    }

    /**
     * Makes a new composite state object.
     *
     * @@param name the identifier for the composite state within its containing
     * namespace
     * @@param commentString the comment for this composite state
     * @@param container the container of this composite state, or null if top state
     * @@param entry the entry action for this composite state, or null if none
     * @@param exit the exit action for this composite state, or null if none
     * @@param doActivity the do activity for this composite state, or null if none
     * @@param isConcurrent true if concurrent processes, otherwise false
     * @@return the new composite state object
     */
    public CompositeState makeCompositeState (String name,
                                              String commentString,
                                              CompositeState container,
                                              Procedure entry,
                                              Procedure exit,
                                              Procedure doActivity,
                                              boolean isConcurrent) {
        CompositeState compositeState = new CompositeState();
        setNamespaceNameComment(compositeState,
                                name,
                                commentString);
        compositeState.setContainer(container);
        compositeState.setIsRegion(false);
        if (container == null)
            compositeState.setStateMachine(stateMachine);
        else {
            container.getSubVertex().add(compositeState);
            if (container.isConcurrent())
                compositeState.setIsRegion(true);
        }
        compositeState.setEntry(entry);
        compositeState.setExit(exit);
        compositeState.setDoActivity(doActivity);
        compositeState.setIsConcurrent(isConcurrent);
        return compositeState;
    }

    /**
     * Makes a new pseudo state object.
     *
     * @@param name the identifier for the pseudo state within its containing
     * namespace
     * @@param commentString the comment for this pseudo state
     * @@param container the container of this pseudo state
     * @@param kind the kind of PseudoState
     * @@return the new pseudo state object
     */
    public PseudoState makePseudoState (String name,
                                        String commentString,
                                        CompositeState container,
                                        int kind) {
        PseudoState pseudoState = new PseudoState();
        setNamespaceNameComment(pseudoState,
                                name,
                                commentString);
        pseudoState.setContainer(container);
        container.getSubVertex().add(pseudoState);
        pseudoState.setKind(kind);
        return pseudoState;
    }

    /**
     * Makes a new state vertex object.
     *
     * @@param name the identifier for the state vertex within its containing
     * namespace
     * @@param commentString the comment for this state vertex
     * @@param container the container of this state vertex
     * @@return the new state vertex object
     */
    public StateVertex makeStateVertex (String name,
                                        String commentString,
                                        CompositeState container) {
        StateVertex stateVertex = new StateVertex();
        setNamespaceNameComment(stateVertex,
                                name,
                                commentString);
        stateVertex.setContainer(container);
        container.getSubVertex().add(stateVertex);
        return stateVertex;
    }

    /**
     * Sets the namespace, name and comment string for the new
     * model element.
     *
     * @@param modelElement the given model element
     * @@param name the identifier for the state machine within its containing
     * namespace
     * @@param commentString the comment for this state machine
     */
    protected void setNamespaceNameComment (ModelElement modelElement,
                                            String name,
                                            String commentString) {
        namespace.addOwnedElement(modelElement);
        modelElement.setNamespace(namespace);
        modelElement.setName(name);
        Comment comment = new Comment();
        comment.setNamespace(namespace);
        comment.setName("");
        comment.setBody(commentString);
        comment.setAnnotatedElement(modelElement);
        modelElement.setComment(comment);
    }

    /**
     * Makes a new transition object.
     *
     * @@param transition the given tranistion shell to add
     * @@param name the identifier for the transition within its containing
     * namespace
     * @@param commentString the comment for this transition
     * @@param guardExpressionLanguage the language in which the guard
     * expression is written
     * @@param guardExpressionBody the body of the guard expression, or null
     * if no guard
     * @@param effect the procedure which is the effect of this transition, or
     * null if no effect
     * @@param trigger the event which triggers this transition
     * @@param source the source state of this transition
     * @@param target the target state of this transition
     */
    public Transition addTransition (Transition transition,
                                     String name,
                                     String commentString,
                                     String guardExpressionLanguage,
                                     Object guardExpressionBody,
                                     Procedure effect,
                                     Event trigger,
                                     StateVertex source,
                                     StateVertex target) {
        setNamespaceNameComment(transition,
                                name,
                                commentString);
        if (guardExpressionBody != null) {
            Guard guard = new Guard();
            setNamespaceNameComment(guard,
                                    name,
                                    commentString);
            BooleanExpression guardExpression = new BooleanExpression();
            guardExpression.setLanguage(guardExpressionLanguage);
            guardExpression.setBody(guardExpressionBody);
            guard.setexpression(guardExpression);
            guard.setTransition(transition);
            transition.setGuard(guard);
        }
        transition.setEffect(effect);
        transition.setTrigger(trigger);
        transition.setSource(source);
        transition.setTarget(target);
        transition.setStateMachine(stateMachine);
        stateMachine.getTransition().add(transition);
        if (source instanceof State &&
            source.equals(target))
            ((State) source).getInternalTransition().add(transition);
        else {
            source.getOutgoing().add(transition);
            target.getIncoming().add(transition);
        }
        return transition;
    }

    /**
     * Sets the state machine for this state machine factory in the case where
     * the state machine already exists.
     *
     * @@param stateMachine the state machine to extend or modify
     */
    public void setStateMachine (StateMachine stateMachine) {
        this.stateMachine = stateMachine;
    }

    /**
     * Sets the namespace for this state machine factory in the case where
     * the state machine already exists.
     *
     * @@param namespace the namespace for the state machine model elements
     */
    public void setNamespace (Namespace namespace) {
        this.namespace = namespace;
    }

    /**
     * Adds an input pin binding for the transition effect
     *
     * @@param transition the given transition
     * @@param inputPin the given input pin
     * @@param boundObject the object bound to the given input pin
     * @@return the input pin bindings for the transition effect
     */
    public void addEffectInputBinding (Transition transition,
                                       InputPin inputPin,
                                       Object boundObject) {
        transition.addEffectInputBinding(inputPin, boundObject);
    }

    /**
     * Adds an output pin binding for the transition effect
     *
     * @@param transition the given transition
     * @@param outputPin the given output pin
     * @@param stateVariable the state variable bound to the given output pin
     * @@return the output pin bindings for the transition effect
     */
    public void addEffectOutputBinding (Transition transition,
                                       OutputPin outputPin,
                                       StateVariable stateVariable) {
        transition.addEffectOutputBinding(outputPin, stateVariable);
    }

    /**
     * Adds an input pin binding for the state entry procedure
     *
     * @@param state the given state
     * @@param inputPin the given input pin
     * @@param boundObject the object bound to the given input pin
     * @@return the input pin bindings for the state entry procedure
     */
    public void addEntryInputBinding (State state,
                                      InputPin inputPin,
                                      Object boundObject) {
        state.addEntryInputBinding(inputPin, boundObject);
    }

    /**
     * Adds an output pin binding for the state entry procedure
     *
     * @@param state the given state
     * @@param outputPin the given output pin
     * @@param stateVariable the state variable bound to the given output pin
     * @@return the output pin bindings for the state entry procedure
     */
    public void addEntryOutputBinding (State state,
                                       OutputPin outputPin,
                                       StateVariable stateVariable) {
        state.addEntryOutputBinding(outputPin, stateVariable);
    }

    /**
     * Adds an input pin binding for the state exit procedure
     *
     * @@param state the given state
     * @@param inputPin the given input pin
     * @@param boundObject the object bound to the given input pin
     * @@return the input pin bindings for the state exit procedure
     */
    public void addExitInputBinding (State state,
                                     InputPin inputPin,
                                     Object boundObject) {
        state.addExitInputBinding(inputPin, boundObject);
    }

    /**
     * Adds an output pin binding for the state exit procedure
     *
     * @@param state the given state
     * @@param outputPin the given output pin
     * @@param stateVariable the state variable bound to the given output pin
     * @@return the output pin bindings for the state exit procedure
     */
    public void addExitOutputBinding (State state,
                                      OutputPin outputPin,
                                      StateVariable stateVariable) {
        state.addExitOutputBinding(outputPin, stateVariable);
    }

    /**
     * Adds an input pin binding for the state doActivity procedure
     *
     * @@param state the given state
     * @@param inputPin the given input pin
     * @@param boundObject the object bound to the given input pin
     * @@return the input pin bindings for the state doActivity procedure
     */
    public void addDoActivityInputBinding (State state,
                                           InputPin inputPin,
                                           Object boundObject) {
        state.addDoActivityInputBinding(inputPin, boundObject);
    }

    /**
     * Adds an output pin binding for the state doActivity procedure
     *
     * @@param state the given state
     * @@param outputPin the given output pin
     * @@param stateVariable the state variable bound to the given output pin
     * @@return the output pin bindings for the state doActivity procedure
     */
    public void addDoActivityOutputBinding (State state,
                                            OutputPin outputPin,
                                            StateVariable stateVariable) {
        state.addDoActivityOutputBinding(outputPin, stateVariable);
    }

}@


1.16
log
@Completed coding of procedure bindings - ready to test them
@
text
@d13 1
a13 1
 * @@version $Id: StateMachineFactory.java,v 1.15 2003/02/07 03:37:04 stephenreed Exp $
d168 1
a173 1
     * @@return the added input pin for the given procedure
d175 5
a179 5
    public InputPin addInputPinToProcedure(String name,
                                           String commentString,
                                           Procedure procedure,
                                           java.lang.Class type) {
        InputPin inputPin = new InputPin();
a185 1
        return inputPin;
d191 1
a196 1
     * @@return the added output pin for the given procedure
d198 5
a202 5
    public OutputPin addOutputPinToProcedure(String name,
                                             String commentString,
                                             Procedure procedure,
                                             java.lang.Class type) {
        OutputPin outputPin = new OutputPin();
a208 1
        return outputPin;
d592 1
d606 9
a614 9
    public Transition makeTransition (String name,
                                      String commentString,
                                      String guardExpressionLanguage,
                                      Object guardExpressionBody,
                                      Procedure effect,
                                      Event trigger,
                                      StateVertex source,
                                      StateVertex target) {
        Transition transition = new Transition();
@


1.15
log
@Continuing to refactor the uml state machine code and improve the
treatment of state variables via the reification of Attribute and Classifier
- Will not cleanly compile yet.
@
text
@d13 1
a13 1
 * @@version $Id: StateMachineFactory.java,v 1.14 2003/02/06 02:57:03 stephenreed Exp $
d114 10
a123 10
    public void addStateVariableToClassifier (String name,
                                              String commentString,
                                              int targetScope,
                                              Object type,
                                              int changeability,
                                              Multiplicity multiplicity,
                                              int ordering,
                                              Expression initialValue) {
        Attribute attribute = new Attribute();
        setNamespaceNameComment(attribute,
d126 8
a133 7
        attribute.setType(type);
        attribute.setChangeability(changeability);
        attribute.setMultiplicity(multiplicity);
        attribute.setOrdering(ordering);
        attribute.setInitialValue(initialValue);
        attribute.setTargetScope(targetScope);
        stateMachine.getContext().addFeature(attribute);
@


1.14
log
@Refactoring of the UML state machine extractor.
Work in progress  and will not all compile.
@
text
@d8 1
d13 1
a13 1
 * @@version $Id: StateMachineFactory.java,v 1.13 2003/01/09 00:00:26 stephenreed Exp $
d55 2
a56 1
     * machine will linked to the given namespace.
d62 2
a63 3
     * @@param context the context Classifier of this state machine, which contains the
     * variables that distinguish the state, and the operations which
     * can be performed during state transitions.
d68 1
a68 2
                                         String commentString,
                                         Object context) {
d74 16
d91 42
a132 1
        return stateMachine;
d177 1
a177 1
                                           Class type) {
d201 1
a201 1
                                             Class type) {
d357 1
a357 1
                                         Class type) {
@


1.13
log
@Changing the state machine interpreter to keep state in the Cyc server.
@
text
@d12 1
a12 1
 * @@version $Id: StateMachineFactory.java,v 1.12 2002/11/14 22:06:05 stephenreed Exp $
d608 113
@


1.12
log
@Completed first set of unit tests for UML State Machine extraction from Cyc.
@
text
@d4 1
d12 1
a12 1
 * @@version $Id: StateMachineFactory.java,v 1.11 2002/11/09 15:19:10 stephenreed Exp $
d95 1
a95 1
                                    String body,
d210 1
a210 1
                                        String body) {
d274 1
a274 1
                                    String body) {
d552 1
a552 1
                                      String guardExpressionBody,
@


1.11
log
@Small mods to update UML association names per the UML doc.
@
text
@d11 1
a11 1
 * @@version $Id: StateMachineFactory.java,v 1.10 2002/11/06 16:35:28 stephenreed Exp $
a574 1
        source.getOutgoing().add(transition);
a575 1
        target.getIncoming().add(transition);
d581 4
@


1.10
log
@Completed first (simple) unit test of UML state machine support.
@
text
@d11 1
a11 1
 * @@version $Id: StateMachineFactory.java,v 1.9 2002/11/06 00:24:35 stephenreed Exp $
d579 1
a579 1
        stateMachine.getTransitions().add(transition);
@


1.9
log
@Added more code for UML state machine interpretation.
@
text
@d11 1
a11 1
 * @@version $Id: StateMachineFactory.java,v 1.8 2002/11/04 21:38:26 stephenreed Exp $
d525 2
@


1.8
log
@Added primitive types for state machine interpretation.
@
text
@d3 1
d11 1
a11 1
 * @@version $Id: StateVertex.java,v 1.2 2002/10/29 23:30:16 stephenreed Exp $
d271 3
a273 3
                                        String commentString,
                                        String language,
                                        String body) {
d285 1
d311 46
d584 9
d594 9
@


1.7
log
@Adding unit test case for simple state machine to increment a number from zero to ten.
@
text
@d8 1
a8 13
 * Provides a factory for creating UML State_Machines objects.
 * <p>
 * Make objects in this order:<br>
 * 1. state machine<br>
 * 2. procedures<br>
 * 3. events<br>
 * 4. states<br>
 * 5. state vertices<br>
 * 6. transistions<p>
 *
 * The context object for the state machine contains the all the variables
 * used in guards, actions, procedures and events.  The context object also
 * implements the operations performed by the state machine.
d10 1
a10 1
 * @@version $Id: StateMachineFactory.java,v 1.6 2002/11/04 02:33:48 stephenreed Exp $
d309 36
a344 2
     * Makes a new state object.  The top (composite) state must be created
     * first, then parent states should be created before their child states.
d346 1
a346 1
     * @@param name the identifier for the state within its containing
d348 15
a362 15
     * @@param commentString the comment for this state
     * @@param container the container (parent) of this state, or null if top state
     * @@param entry the entry action for this state, or null if none
     * @@param exit the exit action for this state, or null if none
     * @@param doActivity the do activity for this state, or null if none
     * @@return the new state object
     */
    public State makeState (String name,
                            String commentString,
                            CompositeState container,
                            Procedure entry,
                            Procedure exit,
                            Procedure doActivity) {
        State state = new State();
        setNamespaceNameComment(state,
d365 1
a365 1
        state.setContainer(container);
d367 1
a367 1
            state.setStateMachine(stateMachine);
d369 5
a373 5
            container.getSubVertex().add(state);
        state.setEntry(entry);
        state.setExit(exit);
        state.setDoActivity(doActivity);
        return state;
d389 7
a395 7
    public State makeCompositeState (String name,
                                     String commentString,
                                     CompositeState container,
                                     Procedure entry,
                                     Procedure exit,
                                     Procedure doActivity,
                                     boolean isConcurrent) {
d519 1
@


1.6
log
@Fixed compilation error.
@
text
@d22 1
a22 1
 * @@version $Id: StateMachineFactory.java,v 1.5 2002/11/04 02:21:04 stephenreed Exp $
d125 1
d127 4
a130 4
    public void addInputPinToProcedure(String name,
                                       String commentString,
                                       Procedure procedure,
                                       Class type) {
d138 1
d149 1
d151 4
a154 4
    public void addOutputPinToProcedure(String name,
                                        String commentString,
                                        Procedure procedure,
                                        Class type) {
d162 1
d304 1
d306 4
a309 4
    public void addParameterToEvent(String name,
                                    String commentString,
                                    Event event,
                                    Class type) {
d317 1
d392 24
@


1.5
log
@Added more support for UML state machine interpretation.
@
text
@d22 1
a22 1
 * @@version $Id: StateMachineFactory.java,v 1.4 2002/11/03 22:19:30 stephenreed Exp $
d285 4
a288 4
        TimeExpression timeExpression = new TimeExpression();
        timeExpression.setLanguage(language);
        timeExpression.setBody(body);
        timeEvent.setTimeExpression(timeExpression);
d446 8
a453 8
    public State makeTransition (String name,
                                 String commentString,
                                 String guardExpressionLanguage,
                                 String guardExpressionBody,
                                 Procedure effect,
                                 Event trigger,
                                 StateVertex source,
                                 StateVertex target) {
@


1.4
log
@Moved Procedure from commonbehavior to core UML package.
@
text
@d22 1
a22 1
 * @@version $Id: StateMachineFactory.java,v 1.3 2002/11/01 23:40:27 stephenreed Exp $
d158 1
a158 1
        procedure.getResult().add(inputPin);
a221 3
        setNamespaceNameComment(changeExpression,
                                name,
                                commentString);
d240 1
a240 1
        CompletionEvent completionEvent = new CompletionEvent();
a243 1
        completionEvent.setState(state);
d248 45
d309 2
a310 1
        parameter.setBehavioralFeature(Event);
a314 21
     * Makes a new state vertex object.
     *
     * @@param name the identifier for the state vertex within its containing
     * namespace
     * @@param commentString the comment for this state vertex
     * @@param container the container of this state vertex
     * @@return the new state vertex object
     */
    public StateVertex makeStateVertex (String name,
                                        String commentString,
                                        CompositeState container) {
        StateVertex stateVertex = new StateVertex();
        setNamespaceNameComment(stateVertex,
                                name,
                                commentString);
        stateVertex.setContainer(container);
        container.getSubVertex().add(stateVertex);
        return stateVertex;
    }

    /**
d389 21
d428 53
@


1.3
log
@Adding code to StateMachineFactory
@
text
@d5 1
d22 1
a22 1
 * @@version $Id: StateMachineFactory.java,v 1.2 2002/11/01 23:24:07 stephenreed Exp $
d47 5
d54 1
a54 1
    StateMachine stateMachine;
d63 2
a64 1
     * Makes a new state machine object.
d66 1
a66 1
     * @@param namespace the state machine namespace
d75 1
a75 1
    public StateMachine makeStateMachine(String namespace,
d80 4
a83 6
        stateMachine.setNamespace(namespace);
        stateMachine.setName(name);
        Comment comment = new Comment();
        comment.setBody(commentString);
        comment.setAnnotatedElement(stateMachine);
        stateMachine.setComment(comment);
d91 1
a91 3
     *
     * @@param namespace the state vertex namespace
     * @@param name the identifier for the state vertex within its containing
d93 1
a93 1
     * @@param commentString the comment for this state vertex
d95 1
d102 1
a102 2
    public Procedure makeProcedure (String namespace,
                                    String name,
d105 2
a106 3
                                    boolean isList,
                                    Expression expression,
                                    Method method) {
d108 3
a110 6
        procedure.setNamespace(namespace);
        procedure.setName(name);
        Comment comment = new Comment();
        comment.setBody(commentString);
        comment.setAnnotatedElement(procedure);
        procedure.setComment(comment);
d112 1
a113 2
        procedure.setExpression(expression);
        procedure.setMethod(method);
d117 154
a274 1
     * @@param namespace the state vertex namespace
d281 1
a281 2
    public StateVertex makeStateVertex (String namespace,
                                        String name,
d285 3
a287 6
        stateVertex.setNamespace(namespace);
        stateVertex.setName(name);
        Comment comment = new Comment();
        comment.setBody(commentString);
        comment.setAnnotatedElement(stateVertex);
        stateVertex.setComment(comment);
a296 1
     * @@param namespace the state namespace
d306 1
a306 2
    public State makeState (String namespace,
                            String name,
d313 3
a315 6
        state.setNamespace(namespace);
        state.setName(name);
        Comment comment = new Comment();
        comment.setBody(commentString);
        comment.setAnnotatedElement(state);
        state.setComment(comment);
a329 1
     * @@param namespace the composite state namespace
d340 1
a340 2
    public State makeCompositeState (String namespace,
                                     String name,
d348 3
a350 6
        compositeState.setNamespace(namespace);
        compositeState.setName(name);
        Comment comment = new Comment();
        comment.setBody(commentString);
        comment.setAnnotatedElement(compositeState);
        compositeState.setComment(comment);
d366 22
@


1.2
log
@Removed references to Action per UML Action Semantics revision.
@
text
@d21 1
a21 1
 * @@version $Id: StateMachineFactory.java,v 1.1 2002/11/01 16:18:53 stephenreed Exp $
d78 1
d83 36
d140 1
d173 1
d213 1
@


1.1
log
@More support for UML StateMachines.
@
text
@d11 5
a15 6
 * 2. actions<br>
 * 3. procedures<br>
 * 4. events<br>
 * 5. states<br>
 * 6. state vertices<br>
 * 7. transistions<p>
d21 1
a21 1
 * @@version $Id: Transition.java,v 1.3 2002/10/29 23:30:17 stephenreed Exp $
d82 1
d126 3
a128 3
                            Action entry,
                            Action exit,
                            Action doActivity) {
d164 3
a166 3
                                     Action entry,
                                     Action exit,
                                     Action doActivity,
@

