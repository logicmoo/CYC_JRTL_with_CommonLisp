head	1.9;
access;
symbols
	PRE_1_0:1.8;
locks; strict;
comment	@# @;


1.9
date	2006.10.21.16.49.16;	author dmiles;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.07.11.27.07;	author dmiles;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.04.03.40.57;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.20.16.38.35;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.07.18.13.12;	author dmiles;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.02.04.20.32;	author dmiles;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.10.19.52.19;	author dmiles;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.29.23.35.31;	author dmiles;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.24.09.04.32;	author dmiles;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.chat;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringReader;
import java.lang.reflect.Method;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;

import org.opencyc.api.CycAccess;
import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycNart;
import org.opencyc.cycobject.CycSymbol;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.cycobject.ELMt;
import org.opencyc.kif.CycListKifParser;
import org.opencyc.util.Log;

public class IrcChat extends Thread  implements ChatSender {

    /**
     * IRC Bot details
     */
    // Name Bot goes by on IRC
    public String ircNick = "Cycbot";

    // WHOIS Information
    public String ircComment = "http://www.opencyc.org";

    // IRC Auto-join
    public String ircChannel = "#opencyc";

    /**
     * IRC Sever details
     */
    public String ircServer = "irc.freenode.net";

    public int ircPort = 6667;

    // IRC Unkown message replies sentence to
    public String ircDestination = "#opencyc";

    // ArrayList of paraphrased writable locations
    public ArrayList paraphrased = new ArrayList();

    // IRC Debug messages sentence to ( may send to an IRC username instead of channel )
    public String ircDebug = "dmiles";

    /**
     * IRC Server comunication
     */
    private Socket ircServerSocket =null;
    private InputStream ircInputStream = null;
    private OutputStream ircOutputStream = null;
    private BufferedReader ircInputReader = null;
    private BufferedWriter ircOutputWriter = null;

    /**
     * Telent DCC Chat Server
     */
    //public DccServerThread dccServer = null;

    /**
     * reference to CycAccess (OpenCyc server)
     */
    public CycAccess cyc = null;

    /**
     * reference to ChatterBot
     */
    public org.opencyc.chat.ChatterBot chatterBot = null;

    public boolean running = false;

    /**
     * Creates a basic unstarted IRC Bot
     */
    public IrcChat() {
    }

    /**
     * Creates a full running IRC Bot
     */
    public IrcChat(CycAccess access,
                   String nick,
                   String comment,
                   String server,
                   int port,
                   String channel) {
        // set the bot's nickname and description
        ircNick = nick;
        ircComment = comment;
        ircServer = server;
        ircPort = port;
        ircChannel = channel;
        cyc = access;
    }

    /**
     * Provide a command line function to launch the IrcChat application.
     */
    public static void main(String[] args) {
        try {
            IrcChat ircBot = new IrcChat();
            ircBot.cyc = new CycAccess();
            if ( args.length > 0 )
                ircBot.ircNick = args[0];
            if ( args.length > 1 )
                ircBot.ircChannel = args[1];
            if ( args.length > 2 )
                ircBot.ircServer = args[2];
            if ( args.length > 3 )
                ircBot.ircPort = Integer.parseInt((args[3]));
            System.out.println("Lauching IrcChat: n\nick='" + ircBot.ircNick +
                               "' \nchannel='" + ircBot.ircChannel + "' \nserver='" +
                               ircBot.ircServer + ":'"+ircBot.ircPort + "");
            ircBot.run();
            System.exit(0);
        } catch ( Exception e ) {
            e.printStackTrace(System.err);
            System.exit(1);
        }
    }

    /**
     * Connects Bot to an IRC server
     */
    public void ircConnect() {
        Log.makeLog();
        try {
            ircServerSocket = new Socket(ircServer, ircPort);
        } catch ( Exception e ) {
            System.err.println("error Connecting to IRC server");
            e.printStackTrace();
        }
        try {
            ircInputStream = ircServerSocket.getInputStream();
            ircOutputStream = ircServerSocket.getOutputStream();
        } catch ( Exception e ) {
            System.err.println("error opening streams to IRC server");
            e.printStackTrace();
        }
        ircInputReader = new BufferedReader(new InputStreamReader(ircInputStream));
        ircOutputWriter = new BufferedWriter(new OutputStreamWriter(ircOutputStream));
        try {
            // send user info
            ircOutputWriter.write("user " + ircNick + " opencyc irc :" + ircComment);
            ircOutputWriter.newLine();
            ircOutputWriter.write("nick " + ircNick);
            ircOutputWriter.newLine();
            ircOutputWriter.flush();
        } catch ( Exception e ) {
            System.out.println("ircLogOn error: " + e);
        }
        ircJoin(ircChannel);
        //paraphrased.add(ircChannel);
        ircJoin(ircDebug);
        this.running = true;
        startChatterBot();
        startPlugins();
        return;
    }

    /**
     * Disconnct Bot from an IRC server
     */
    public void ircDisconnect() {
        try {
            chatterBot.finalize();
            chatterBot = null;
            ircOutputWriter.write("QUIT this.ircDisconnect();");
            ircOutputWriter.newLine();
            ircOutputWriter.flush();
        } catch ( Exception e ) {
            System.out.println("ircLogOff error: " + e);
            e.printStackTrace();
        }
        // close the IO streams to the IRC server
        try {
            ircInputReader.close();
            ircOutputWriter.close();
            ircInputReader = null;
            ircOutputWriter = null;
            ircServerSocket.close();
            ircServerSocket = null;
        } catch ( IOException e ) {
            System.err.println("Error ircDisconnecting from IRC server");
            e.printStackTrace();
        }
    }

    public void run() {
        ircConnect();
        if ( ircChannel!=null ) ircJoin(ircChannel);
        while ( !this.interrupted() && running )
            try {
                this.serviceLoop();
            } catch ( Exception e ) {
                System.out.println(""+e);
            }
    }

    public void restartChatterBot() {
        terminateChatterBot();
        startChatterBot();
    }

    public void terminateChatterBot() {
        if ( chatterBot!=null ) {
            try {
                chatterBot.finalize();
            } catch ( Exception e ) {
                e.printStackTrace(System.err);
            }
            chatterBot = null;
        }
    }

    public void startChatterBot() {
        if ( chatterBot==null ) {
            try {
                chatterBot = new ChatterBot(this);
                chatterBot.initialize();
            } catch ( Exception e ) {
                e.printStackTrace(System.err);
            }
        }
    }

    public void serviceLoop() throws Exception {
        serviceIRCServer();
    }

    /**
     * Sends a raw string to the IRC server
     */
    public boolean ircSend(String message) {
        System.out.println("irc: '" + message + "'");
        try {
            ircOutputWriter.write(message);
            ircOutputWriter.newLine();
            ircOutputWriter.flush();
        } catch ( IOException e ) {
            return false;
        }
        return true;
    }

    public void ircJoin(String channel) {
        ircSend("JOIN "+channel);
    }

    public void ircPart(String channel) {
        ircSend("PART "+channel);
    }

    /**
     * Send a notice to an IRC user
     * @@param destination String
     * @@param message String
     */
    public void sendNotice(String destination, String message) {
        ircSend("notice " + destination + " :" + message);
    }

    /**
     * Send a public message to an IRC user
     * @@param destination String
     * @@param message String
     */
    public boolean sendMessage(String destination, Object post) {
        if ( post==null || destination==null )
            return false;
        // Wait a 1/2 sec (Keeps from flooding off server)
        try {
            Thread.sleep(500);
        } catch ( InterruptedException e ) {
        }
        if ( post instanceof Iterator ) {
            while ( ((Iterator)post).hasNext() ) {
                try {
                    if ( ircInputReader.ready() )
                        if ( ircInputReader.readLine().trim().endsWith(".") )
                            return true;
                } catch ( Exception e ) {
                }
                sendMessage(destination,((Iterator)post).next());
            }
            return true;
        }
        if ( post instanceof BufferedReader ) {
            String line = null;
            try {
                while ( (line = ((BufferedReader)post).readLine()) != null )
                    sendMessage(destination,line);
            } catch ( Exception e ) {
                System.out.println(""+e);
                return false;
            }
            return true;
        }
        if ( post instanceof CycList && isParaphrased(destination) )
            return sendMessage(destination,attemptParaphrase((CycList)post) + " (" + ((CycList)post).toString() + ")");
        String message = post.toString().trim();
        if ( message.contains("\n") || message.contains("\r") )
            return sendMessage(destination,new BufferedReader(new StringReader(message)));
        if ( message.length() > 200 ) {
            int justify = message.substring(190).indexOf(' ')+190;
            ircSend("privmsg " + destination + " :" + message.substring(0,justify-1));
            return sendMessage(destination,message.substring(justify));
        }
        return ircSend("privmsg " + destination + " :" + message);
    }



    public String attemptParaphrase(Object post) {
        //Log.current.println("attemptParaphrase=" + post);
        if ( post == null )
            return null;
        try {
            if ( post instanceof Iterator ) {
                if ( !(((Iterator)post).hasNext()) )
                    return "none.";
                StringBuffer sb = new StringBuffer(attemptParaphrase(((Iterator)post).next()));
                while ( ((Iterator)post).hasNext() )
                    sb.append(", ").append(attemptParaphrase(((Iterator)post).next()));
                return sb.toString();
            }
            if ( post instanceof CycConstant )
                return cyc.converseString("(generate-phrase " + ((CycConstant)post).stringApiValue() +  ")");
            if ( post instanceof CycNart )
                return cyc.converseString("(generate-phrase '" + ((CycNart)post).cyclify() +  ")");
            if ( post instanceof CycVariable )
                return(((CycVariable)post).stringApiValue());
            if ( post instanceof CycList ) {
                if ( ((CycList)post).isEmpty() )
                    return "an empty list ";
                if ( !((CycList)post).isProperList() )
                    // return attemptParaphrase(((CycList)post).first()) + " = " + (((CycList)post).rest());
                    return attemptParaphrase(((CycList)post).first()) + " = " + attemptParaphrase(((CycList)post).rest());
                if ( ((CycList)post).first() instanceof CycList )
                    return attemptParaphrase(((CycList)post).iterator());
                return cyc.converseString("(generate-phrase '" + ((CycList)post).cyclify() +  ")");
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }
        return post.toString();
    }

    /**
     * Receives and parses IRC Server messages
     */
    public void serviceIRCServer() throws Exception {
        // Wait a 1/10th sec
        try {
            Thread.sleep(100);
        } catch ( InterruptedException e ) {
        }
        // Data ?
        if ( !ircInputReader.ready() )
            return;
        String message = ircInputReader.readLine();
        //System.out.println(message);
        // send a pong back
        if ( message.substring(0,4).equalsIgnoreCase("ping") ) {
            ircSend("pong " + message.substring(5));
            return;
        }
        serviceIRCSession(message);
    }

    /**
     * Receives and parses IRC Session messages
     */
    public void serviceIRCSession(String message) {
        String prefix = null;
        String command = null;
        String params = null;
        String user = null;
        // check for the prefix
        if ( message.substring(0,1).equals(":") ) {
            prefix = message.substring(1, message.indexOf(' '));
            message = message.substring(message.indexOf(' ') + 1);
        }
        // extract the command
        command = message.substring(0, message.indexOf(' '));
        // get the parameters (the rest of the message)
        params = message.substring(message.indexOf(' ') + 1);
        if ( params.toLowerCase().startsWith(":closing") ) {
            ircConnect();
            return;
        }
        try {
            int col = params.indexOf(':');
            String destination = params.substring(0,col-1).trim();
            ircDestination = destination;
            params = params.substring(col+1).trim();
            serviceIRCTransaction(prefix.substring(0, prefix.indexOf('!')),
                                  prefix,
                                  command,
                                  destination,
                                  params);
        } catch ( Exception e ) {
        }
    }

    /**
     * Process an IRC Transaction
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
     *     params are in the form
     *     <my nick> :<message>
     *     or
     *     <my nick> <message>
     */
    public void serviceIRCTransaction(String from, String hostmask, String command, String destination,String params) {
        if ( hostmask.startsWith(ircNick) )
            return;
        if ( command.equalsIgnoreCase("PRIVMSG") )
            servicePublicMessage(from, hostmask, destination, params.trim());
    }

    /**
     * Process a Public message (PRIVMSG to Channel)
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
     *     params are in the form
     *     <my nick> :<message>
    or
    <my nick> <message>
     */
    public void servicePublicMessage(String from, String hostmask, String returnpath,String params) {
        if ( !returnpath.startsWith("#") )
            returnpath = from;
        String lcparams = params.toLowerCase().trim();
        int ccol = params.indexOf(':');
        if ( ccol<0 )
            ccol = params.indexOf(' ');
        if ( ccol>1 ) {
            String token = lcparams.substring(0,ccol).trim();
            params = params.substring(ccol+1).trim();
            if ( serviceToken(from, hostmask, returnpath, token,params) )
                return;
        } else {
            if ( serviceToken(from, hostmask, returnpath, lcparams, params) )
                return;
        }
        serviceChatter(from,hostmask,params,returnpath);
    }

    /**
     * Process a Token message
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
     *     params are in the form
     *     <my nick> :<message>
     *     or
     *     <my nick> <message>
     */
    public boolean serviceToken(String from,
                                String hostmask,
                                String returnpath,
                                String token,
                                String params) {
        System.out.println("token: '" + token + "' params: '" + params + "'");
        if ( token.equals("hello") ) {
            sendMessage(returnpath, "hello " + from);
            return true;
        }
        if ( token.equals("time") ) {
            sendMessage(returnpath, "the time was " + (new Date()).toString());
            return true;
        }
        if ( token.equals("restart") ) {
            restartChatterBot();
            return true;
        }
        if ( token.equals("help") ) {
            sendHelp(returnpath,params);
            return true;
        }
        if ( token.equals("echo") ) {
            sendMessage(returnpath, params);
            return true;
        }
        if ( token.equals("cyclify") ) {
            sendMessage(returnpath, toCycListString(params));
            return true;
        }
        if ( token.equals("paraphrase") ) {
            if ( params.startsWith("#") ) {
                paraphrased.add(params);
                return true;
            }
            sendMessage(returnpath, attemptParaphrase(toCycList(params)));
            return true;
        }
        if ( token.equals("noparaphrase") ) {
            paraphrased.remove(params);
            return true;
        }
        if ( token.equals("subl") ) {
            serviceSubL(from,returnpath, params);
            return true;
        }
        if ( token.equals("debug") ) {
            ircDebug = params;
            return true;
        }
        if ( token.equals("ask") ) {
            serviceQuery(from,returnpath, params);
            return true;
        }
        if ( token.equals("mt") ) {
            try {
                CycConstant mt = cyc.makeCycConstant(params);
                cyc.assertIsa(mt, cyc.makeCycConstant("#$Microtheory"),cyc.baseKB);
                mtUser.put(from, mt);
            } catch ( Exception e ) {
            }
            return true;
        }
        if ( token.equals("bsh") ) {
            try {
                if (bshObj!=null) {
                    sendMessage(returnpath, bshInv.invoke(bshObj,new Object[]{params}));
                }
            } catch ( Exception e ) {
                sendMessage(returnpath, e);
            }
            return true;
        }
        if ( token.equals("prove") ) {
            serviceProve(from,returnpath, params);
            return true;
        }
        if ( token.equals("query") ) {
            serviceQueryUser(from,returnpath, params);
            return true;
        }
        if ( token.equals("assert") ) {
            serviceAssert(from,returnpath, params);
            return true;
        }
        if ( token.equals("join") ) {
            ircJoin(params);
            return true;
        }
        if ( token.startsWith("part") ) {
            ircPart(params);
            return true;
        }
        if ( token.startsWith("putserv") ) {
            ircSend(params);
            return true;
        }
        if ( servicePlugin( from,  hostmask,  returnpath, token, params) ) return true;
        return false;
    }

    public boolean servicePlugin(String from,
                                 String hostmask,
                                 String returnpath,
                                 String token,
                                 String params) {
        return false;
    }

    public Object bshObj;
    public Method bshInv;
    public Method bshSet;
    public Class bshcls;

    public void startPlugins() {
        try {
            bshcls = Class.forName("bsh.Interpreter");
            bshObj = bshcls.newInstance();
            bshInv = bshcls.getMethod("eval",new Class[]{String.class});
            bshSet = bshcls.getMethod("set",new Class[]{String.class,Object.class});
            addObj("client",this);
            addObj("cyc",cyc);
        } catch ( Exception e ) {
            e.printStackTrace();
        }
        return;
    }

    public void addObj(String name, Object val) {
        try {
            bshSet.invoke(bshObj,new Object[]{name,val});
        } catch ( Exception e ) {
        }
    }

    public void sendHelp(String returnpath, String params) {
        sendMessage(returnpath,"usage: help <hello|time|join|part|ask|query|assert|cyclify>");
    }

    /**
     * Process a SubL command
     * @@param destination String nickname of the user who sent the message
     * @@param message String the command
     * params are in the form
     * <my nick> :<message>
     * or
     * <my nick> <message>
     */
    public void serviceSubL(String cyclist, String returnpath, String subl) {
        try {
            sendAnswers(returnpath,cyc.converseObject(subl));
        } catch ( Exception e ) {
            sendMessage(returnpath, ""+ e    /*  + "\" " + " trying to eval \"" + subl +
                        "\" " + "from \"" + cyclist + "\" with returnpath \""+returnpath + "\""*/ );
        }
    }

    /**
     * Process a Query command
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
     *     params are in the form
     *     <my nick> :<message>
     *     or
     *     <my nick> <message>
     */
    public void serviceQuery(String cyclist,String returnpath, String query) {
        try {
            sendAnswers(returnpath, cyc.converseObject( "(cyc-query '" +
                                                        toCycListString(query) + " #$InferencePSC)"));
        } catch ( Exception e ) {
            sendMessage(returnpath, ""+ e);
        }
    }

    /**
     * Process a Prove command (Query with proof)
     * @@param destination String nickname of the user who sent the message
     * @@param message String the command
     * params are in the form
     * <my nick> :<message>
     * or
     * <my nick> <message>
     */
    public void serviceProve(String cyclist,String returnpath, String query) {
        try {
            sendAnswers(returnpath, cyc.converseObject( "(fi-prove '" +
                                                        toCycListString(query) + " #$InferencePSC)"));
        } catch ( Exception e ) {
            sendMessage(returnpath, ""+ e);
        }
    }

    /**
     * Process an Ask command
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
     * params are in the form
     * <my nick> :<message>
     * or
     * <my nick> <message>
     */
    public void serviceQueryUser(String cyclist,String returnpath, String query) {
        try {
            sendAnswers(returnpath, cyc.converseObject( "(cyc-query '" +toCycListString(query) + " " + mtForUser(cyclist).stringApiValue() + ")"));
        } catch ( Exception e ) {
            sendMessage(returnpath, ""+ e);
        }
    }

    /**
     * Process an Assert command
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
     * params are in the form
     * assert:<message>
     * or
     * <my nick>  <message>
     */
    public void serviceAssert(String cyclist,String returnpath, String sentence) {
        serviceSubL(cyclist, returnpath, "(cyc-assert '" + toCycListString(sentence) + " " +
                    mtForUser(cyclist).stringApiValue() + ")");
    }

    /**
    * Process an Assert command
    * @@param destination String nickname of the user who sentence the message
    * @@param message String the command
    *  params are in the form
    *  assert:<message>
    *  or
    *  <my nick>  <message>
    */
    public void serviceChatter(String cyclist,String identity,String message, String returnpath) {
        ircDestination = returnpath;
        return;

        //	try {
        //          if ( chatterBot!=null ) chatterBot.receiveChatMessage(cyclist, cyclist    /*identity hostmask?*/,message);
        //	} catch ( Exception e ) {
        //	    e.printStackTrace(System.out);
        // sendDebug(""+e);
        //	}
    }

    public HashMap mtUser = new HashMap();

    /**
     * Returns a Mt for a user
     */
    public CycFort mtForUser(String cyclist) {
        ELMt mt = (ELMt) mtUser.get(cyclist);
        if ( mt==null ) {
            try {
                mt = cyc.makeELMt(cyc.findOrCreate("#$"+cyclist+"ChatMt"));
                cyc.assertIsa(mt.cyclify(),cyc.findOrCreate("#$Microtheory").cyclify(),CycAccess.baseKB.cyclify());
            } catch ( Exception e ) {
                mt = cyc.baseKB;
            }
            sendMessage(ircDestination,"Using microtheory: " + mt.cyclify());
            sendMessage(ircDestination," for assertions until " + cyclist + " types \"mt <something>\"");
            mtUser.put(cyclist,mt);
        }
        return(CycFort)mt;
    }

    /**
     * Returns true if Paraphrased for a destination/returnpath
     */
    public boolean isParaphrased(String destination) {
        return( paraphrased.contains(destination));
    }

    /**
     * Cyclifys a sentence a string
     */
    public CycList toCycList(String sentence) {
        try {
            return(((CycList)((new CycListKifParser(cyc)).read(sentence))));
        } catch ( Exception e ) {
            return null;
        }
    }

    /**
     * Cyclifys a sentence to a string
     */
    public String toCycListString(String sentence) {
        try {
            return(((CycList)((new CycListKifParser(cyc)).read(sentence))).cyclify());
        } catch ( Exception e ) {
            return null;
        }
    }

    public static CycSymbol SYMBOL_NIL = new CycSymbol("NIL");

    /**
     * Sends the Answer message from Cyc to returnpath
     */
    public void sendAnswers(String returnpath, Object results) {

        if ( results instanceof CycSymbol ) {
            if ( results.equals(SYMBOL_NIL) ) {
                sendMessage(returnpath,"no answers found");
                return;
            }
        }

        if ( results instanceof CycList ) {
            CycList answers = (CycList) results;
            if ( answers.size()==1 && answers.first().equals(IrcChat.SYMBOL_NIL) ) {
                sendMessage(returnpath,"true sentence");
                return;
            }
            if ( answers.toString().length()>120 ) {
                if ( answers.size()>50 ) {
                    sendMessage(returnpath,"Your question returned " + answers.size() +
                                " answers .. please refine. (here are the first five)");
                    CycList five = new CycList();
                    for ( int i=0 ; i<5 ; i++ ) five.add(answers.get(i));
                    sendAnswers(returnpath,five);
                    return;
                }
                sendMessage(returnpath,answers.iterator());
                return;
            }
        }
        sendMessage(returnpath,results);
    }

    public void sendDebug(String message) {
        sendMessage(ircDebug ,message);
    }

    /**
     * Sends the chat message from Cyc into the chat system.
     */

    public void sendChatMessage(String chatMessage) {
        // sendMessage(ircDestination,chatMessage);
    }

    /**
     * Receives chat messages from the user.
     */
    private String receiveChatMessage() throws IOException {
        System.out.print("user> ");
        return "foo";
    }

    public void recievedConsoleMsg(DccClientHandlerThread client,String message) {
        System.out.print("recievedConsoleMsg " + client + ": " + message);
    }

    public void listenForConnections(int port) {
        try {
            //dccServer = new DccServerThread(this,port);
            //dccServer.start();
        } catch ( Exception e ) {
        }
    }

    public class DccServerThread extends Thread {
        public boolean listening = true;
        private ServerSocket serverSocket = null;
        private int serverPort = 4444;
        private IrcChat IrcChat = null;
        public HashMap clients = null;

        public DccServerThread(IrcChat ircBot, int port) throws IOException {
            IrcChat =  ircBot;
            serverPort = port;
            clients = new HashMap();
            serverSocket = new ServerSocket(port);
            this.start();
        }

        public void run() {
            try {
                while ( listening ) {
                    Socket thisClient = serverSocket.accept();
                    String username = getLogin(thisClient);
                    DccClientHandlerThread clientThread = new DccClientHandlerThread(IrcChat, thisClient);
                    clientThread.run();
                    clients.put(username,clientThread);
                }
                serverSocket.close();
            } catch ( Exception e ) {
            }
        }

        public String getLogin(Socket thisClient) {
            return thisClient.toString();
        }
    }

    public class DccClientHandlerThread extends Thread {
        private Socket socket = null;
        private IrcChat IrcChat = null;
        private PrintWriter out = null;
        private BufferedReader in = null;


        public DccClientHandlerThread(IrcChat ircBot,Socket socket) {
            super("DccClientThread");
            this.socket = socket;
        }

        public void println(String message) {
            out.println(message);
        }

        public void run() {
            String inputLine = null;
            try {
                out = new PrintWriter(socket.getOutputStream(), true);
                in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                while ( (inputLine = in.readLine()) != null ) {
                    IrcChat.recievedConsoleMsg(this,inputLine);
                }
            } catch ( IOException e ) {
                e.printStackTrace();
            }
        }

        public void disconnect() {
            try {
                out.close();
                in.close();
                socket.close();
            } catch ( IOException e ) {
                e.printStackTrace();
            }
        }
    }
}






@


1.8
log
@Added the bsh refernce but not requiring the beanshell jar
@
text
@d3 27
a29 11
import java.lang.*;
import java.lang.reflect.*;
import java.io.*;
import java.util.*;
import java.net.*;
import org.opencyc.api.*;
import org.opencyc.chat.*;
import org.opencyc.cycobject.*;
import org.opencyc.kif.*;
import org.opencyc.util.*;
import ViolinStrings.*;
d317 1
a317 1
        if ( ViolinStrings.Strings.contains(message,"\n") || ViolinStrings.Strings.contains(message,"\r") )
d725 1
a725 1
        CycConstant mt = (CycConstant) mtUser.get(cyclist);
d728 2
a729 2
                mt = cyc.makeCycConstant("#$"+cyclist+"ChatMt");
                cyc.assertIsa(mt,cyc.makeCycConstant("#$Microtheory"),cyc.baseKB);
@


1.7
log
@Initial check in
@
text
@d4 1
d27 1
a27 1
    public String ircChannel = "#cyclbot";
d32 1
a32 1
    public String ircServer = "irc.openprojects.net";
d37 1
a37 1
    public String ircDestination = "#cyclbot";
d43 1
a43 1
    public String ircDebug = "#cycbot";
d193 4
a196 4
            this.serviceLoop();
        } catch ( Exception e ) {
            System.out.println(""+e);
        }
d431 1
a431 1
        if (!returnpath.startsWith("#"))
d521 10
d567 5
d573 10
d586 7
d627 1
a627 1
                        toCycListString(query) + " #$InferencePSC)"));
d645 1
a645 1
                        toCycListString(query) + " #$InferencePSC)"));
d717 2
a718 2
            sendMessage(ircDestination,"Using microtheory" + mt.cyclify() +
                        " for assertions until " + cyclist + " types \"mt <something>\"");
d760 5
a764 4
    if ( results instanceof CycSymbol ) {
        if (results.equals(SYMBOL_NIL)) {
        sendMessage(returnpath,"no answers found");
        return;
a765 1
    }
d767 16
a782 13
    if ( results instanceof CycList ) {
        CycList answers = (CycList) results;
        if ( answers.size()==1 && answers.first().equals(IrcChat.SYMBOL_NIL)) {
        sendMessage(returnpath,"true sentence");
        return;
        }
        if ( answers.toString().length()>120 ) {
            if ( answers.size()>50 ) {
                sendMessage(returnpath,"Your question returned " + answers.size() +
                            " answers .. please refine. (here are the first five)");
                CycList five = new CycList();
                for ( int i=0 ; i<5 ; i++ )	five.add(answers.get(i));
                sendAnswers(returnpath,five);
a784 2
            sendMessage(returnpath,answers.iterator());
            return;
d786 1
a786 2
    }
    sendMessage(returnpath,results);
d798 1
a798 1
       // sendMessage(ircDestination,chatMessage);
@


1.6
log
@Removing previous state machine implementation which is
replaced by org.opencyc.uml.statemachine package
@
text
@a213 2


d395 5
a399 1
            serviceIRCTransaction(prefix.substring(0, prefix.indexOf('!')),prefix,command,destination, params);
d457 5
a461 1
    public boolean serviceToken(String from, String hostmask, String returnpath,String token,String params) {
d514 2
a515 2
                cyc.assertIsa(mt,cyc.makeCycConstant("#$Microtheory"),cyc.baseKB);
                mtUser.put(from,mt);
d566 1
a566 1
     * @@param destination String nickname of the user who sentence the message
d573 1
a573 1
    public void serviceSubL(String cyclist,String returnpath, String subl) {
d602 1
a602 1
     * @@param destination String nickname of the user who sentence the message
d645 1
a645 1
        serviceSubL(cyclist,returnpath, "(cyc-assert '" +toCycListString(sentence) + " " +
@


1.5
log
@Added ability for bot to take private messages
@
text
@d1 861
a861 913

package org.opencyc.chat;

import java.lang.*;
import java.io.*;
import java.util.*;
import java.net.*;

import org.opencyc.api.*;
import org.opencyc.chat.*;
import org.opencyc.cycobject.*;
import org.opencyc.kif.*;
import org.opencyc.util.*;
import ViolinStrings.*;


public class IrcChat extends Thread  implements ChatSender {

    /**
     * IRC Bot details
     */

    // Name Bot goes by on IRC
    public String ircNick = "Cycbot";

    // WHOIS Information
    public String ircComment = "http://www.opencyc.org";

    // IRC Auto-join
    public String ircChannel = "#cyclbot";

    /**
     * IRC Sever details
     */
    public String ircServer = "irc.openprojects.net";
    public int ircPort = 6667;

    // IRC Unkown message replies sentence to
    public String ircDestination = "#cyclbot";

    // ArrayList of paraphrased writable locations
    public ArrayList paraphrased = new ArrayList();

    // IRC Debug messages sentence to ( may send to an IRC username instead of channel )
    public String ircDebug = "#cycbot";

    /**
     * IRC Server comunication
     */
    private Socket ircServerSocket =null;
    private InputStream ircInputStream = null;
    private OutputStream ircOutputStream = null;
    private BufferedReader ircInputReader = null;
    private BufferedWriter ircOutputWriter = null;

    /**
     * Telent DCC Chat Server 
     */
    //public DccServerThread dccServer = null;

    /**
     * reference to CycAccess (OpenCyc server)
     */
    public CycAccess cyc = null;


    /**
     * reference to ChatterBot
     */
    public org.opencyc.chat.ChatterBot chatterBot = null;



    public boolean running = false;


    /**
     * Creates a basic unstarted IRC Bot
     *     
     */
    public IrcChat() {
    }

    /**
     * Creates a full running IRC Bot
    *     
    */
    public IrcChat(CycAccess access, String nick, String comment, String server, int port, String channel) {
	// set the bot's nickname and description
	ircNick = nick;
	ircComment = comment;
	ircServer = server;
	ircPort = port;
	ircChannel = channel;
	cyc = access;
    }


    /**
     * Provide a command line function to launch the IrcChat application.  
     *     
     */
    public static void main(String[] args) {
	try {
	    IrcChat ircBot = new IrcChat();
	    ircBot.cyc = new CycAccess();
	    if ( args.length > 0 ) ircBot.ircNick = args[0];
	    if ( args.length > 1 ) ircBot.ircChannel = args[1];
	    if ( args.length > 2 ) ircBot.ircServer = args[2];
	    if ( args.length > 3 ) ircBot.ircPort = Integer.parseInt((args[3]));
	    System.out.println("Lauching IrcChat: n\nick='"+ircBot.ircNick+"' \nchannel='"+ircBot.ircChannel+"' \nserver='"+ircBot.ircServer+":'"+ircBot.ircPort+"");
	    ircBot.run();
	    System.exit(0);
	} catch ( Exception e ) {
	    e.printStackTrace(System.err);
	    System.exit(1);
	}
    }

    /**
     * Connects Bot to an IRC server
     *     
     */
    public void ircConnect() {
	Log.makeLog();
	try {
	    ircServerSocket = new Socket(ircServer, ircPort);
	} catch ( Exception e ) {
	    System.err.println("error Connecting to IRC server");
	    e.printStackTrace();
	}

	try {
	    ircInputStream = ircServerSocket.getInputStream();    
	    ircOutputStream = ircServerSocket.getOutputStream();
	} catch ( Exception e ) {
	    System.err.println("error opening streams to IRC server");
	    e.printStackTrace();                                   
	}

	ircInputReader = new BufferedReader(new InputStreamReader(ircInputStream));
	ircOutputWriter = new BufferedWriter(new OutputStreamWriter(ircOutputStream));  

	try {
	    // send user info
	    ircOutputWriter.write("user " + ircNick + " opencyc irc :" + ircComment);
	    ircOutputWriter.newLine();
	    ircOutputWriter.write("nick " + ircNick);
	    ircOutputWriter.newLine();
	    ircOutputWriter.flush();
	} catch ( Exception e ) {
	    System.out.println("ircLogOn error: " + e);
	}
	ircJoin(ircChannel);
	//paraphrased.add(ircChannel);
	ircJoin(ircDebug);

	this.running = true;

	startChatterBot();
	startPlugins();
	return;
    }

    /**
     * Disconnct Bot from an IRC server
     *     
     */
    public void ircDisconnect() {
	try {
	    chatterBot.finalize();
	    chatterBot = null;
	    ircOutputWriter.write("QUIT this.ircDisconnect();");
	    ircOutputWriter.newLine();
	    ircOutputWriter.flush();
	} catch ( Exception e ) {
	    System.out.println("ircLogOff error: " + e);
	    e.printStackTrace();
	}

	// close the IO streams to the IRC server
	try {
	    ircInputReader.close();
	    ircOutputWriter.close();
	    ircInputReader = null;
	    ircOutputWriter = null;
	    ircServerSocket.close();
	    ircServerSocket = null;

	} catch ( IOException e ) {
	    System.err.println("Error ircDisconnecting from IRC server");
	    e.printStackTrace();
	}
    }

    public void run() {
	ircConnect();
	if ( ircChannel!=null ) ircJoin(ircChannel);
	while ( !this.interrupted() && running )
	    try {
		this.serviceLoop();
	    } catch ( Exception e ) {
		System.out.println(""+e);
	    }
    }

    public void restartChatterBot() {
	terminateChatterBot();
	startChatterBot();
    }

    public void terminateChatterBot() {
	if ( chatterBot!=null ) {
	    try {
		chatterBot.finalize();
	    } catch ( Exception e ) {
		e.printStackTrace(System.err);
	    }
	    chatterBot = null;
	}
    }

    public void startChatterBot() {
	if ( chatterBot==null ) {
	    try {
		chatterBot = new ChatterBot(this);
		chatterBot.initialize();
	    } catch ( Exception e ) {
		e.printStackTrace(System.err);
	    }
	}
    }

    public void serviceLoop() throws Exception {
	serviceIRCServer();
    }

    /**
     * Sends a raw string to the IRC server
     */
    public boolean ircSend(String message) {
	System.out.println("irc: '" + message + "'");
	try {
	    ircOutputWriter.write(message);
	    ircOutputWriter.newLine();
	    ircOutputWriter.flush();
	} catch ( IOException e ) {
	    return false;
	}
	return true;
    }

    public void ircJoin(String channel) {
	ircSend("JOIN "+channel);
    }

    public void ircPart(String channel) {
	ircSend("PART "+channel);
    }
    /**
     * Send a notice to an IRC user
     * @@param destination String
     * @@param message String
     */
    public void sendNotice(String destination, String message) {
	ircSend("notice " + destination + " :" + message);
    }

    /**
     * Send a public message to an IRC user
     * @@param destination String
     * @@param message String
     */
    public boolean sendMessage(String destination, Object post) {

	if ( post==null || destination==null ) return false;

	// Wait a 1/2 sec (Keeps from flooding off server)
	try {
	    Thread.sleep(500);
	} catch ( InterruptedException e ) {
	}

	if ( post instanceof Iterator ) {
	    while ( ((Iterator)post).hasNext() ) {
		try {
		    if ( ircInputReader.ready() )
			if ( ircInputReader.readLine().trim().endsWith(".") ) return true;
		} catch ( Exception e ) {
		}
		sendMessage(destination,((Iterator)post).next());
	    }
	    return true;
	}

	if ( post instanceof BufferedReader ) {
	    String line = null;
	    try {
		while ( (line = ((BufferedReader)post).readLine()) != null ) sendMessage(destination,line);
	    } catch ( Exception e ) {
		System.out.println(""+e);
		return false;
	    }
	    return true;
	}

	if ( post instanceof CycList && isParaphrased(destination) )
	    return sendMessage(destination,attemptParaphrase((CycList)post) + " (" + ((CycList)post).toString() + ")");


	String message = post.toString().trim();

	if ( ViolinStrings.Strings.contains(message,"\n") || ViolinStrings.Strings.contains(message,"\r") )
	    return sendMessage(destination,new BufferedReader(new StringReader(message)));

	if ( message.length() > 200 ) {
	    int justify = message.substring(190).indexOf(' ')+190;
	    ircSend("privmsg " + destination + " :" + message.substring(0,justify-1));
	    return sendMessage(destination,message.substring(justify));
	}

	return ircSend("privmsg " + destination + " :" + message);

    }

    public String attemptParaphrase(Object post) {
	//Log.current.println("attemptParaphrase=" + post);
	if ( post == null ) return null;
	try {

	    if ( post instanceof Iterator ) {
		if ( !(((Iterator)post).hasNext()) ) return "none.";
		StringBuffer sb = new StringBuffer(attemptParaphrase(((Iterator)post).next()));
		while ( ((Iterator)post).hasNext() )
		    sb.append(", ").append(attemptParaphrase(((Iterator)post).next()));
		return sb.toString();
	    }

	    if ( post instanceof CycConstant )
		return cyc.converseString("(generate-phrase " + ((CycConstant)post).stringApiValue() +  ")");

	    if ( post instanceof CycNart )
		return cyc.converseString("(generate-phrase '" + ((CycNart)post).cyclify() +  ")");

	    if ( post instanceof CycVariable )
		return(((CycVariable)post).stringApiValue());

	    if ( post instanceof CycList ) {

		if ( ((CycList)post).isEmpty() )
		    return "an empty list ";

		if ( !((CycList)post).isProperList() )
		   // return attemptParaphrase(((CycList)post).first()) + " = " + (((CycList)post).rest());
		   return attemptParaphrase(((CycList)post).first()) + " = " + attemptParaphrase(((CycList)post).rest());

		if ( ((CycList)post).first() instanceof CycList ) return attemptParaphrase(((CycList)post).iterator());

		return cyc.converseString("(generate-phrase '" + ((CycList)post).cyclify() +  ")");
	    }

	} catch ( Exception e ) {
	    e.printStackTrace();
	}
	return post.toString();
    }

    /**
     * Receives and parses IRC Server messages
     */
    public void serviceIRCServer() throws Exception {

	// Wait a 1/10th sec
	try {
	    Thread.sleep(100);
	} catch ( InterruptedException e ) {
	}

	// Data ?
	if ( !ircInputReader.ready() ) return;

	String message = ircInputReader.readLine();

	//System.out.println(message);

	// send a pong back
	if ( message.substring(0,4).equalsIgnoreCase("ping") ) {
	    ircSend("pong " + message.substring(5));
	    return;
	}
	serviceIRCSession(message);
    }


    /**
     * Receives and parses IRC Session messages
     */
    public void serviceIRCSession(String message) {
	String prefix = null;
	String command = null;
	String params = null;
	String user = null;


	// check for the prefix
	if ( message.substring(0,1).equals(":") ) {
	    prefix = message.substring(1, message.indexOf(' '));
	    message = message.substring(message.indexOf(' ') + 1);
	}

	// extract the command
	command = message.substring(0, message.indexOf(' '));

	// get the parameters (the rest of the message)
	params = message.substring(message.indexOf(' ') + 1);

	if ( params.toLowerCase().startsWith(":closing") ) {
	    ircConnect();
	    return;
	}

	try {
	    int col = params.indexOf(':');
	    String destination = params.substring(0,col-1).trim();
	    ircDestination = destination;
	    params = params.substring(col+1).trim();

	    serviceIRCTransaction(prefix.substring(0, prefix.indexOf('!')),prefix,command,destination, params);
	} catch ( Exception e ) {
	}
    }
    /**
     * Process an IRC Transaction
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
    
    params are in the form
    <my nick> :<message> 
    or
    <my nick> <message>	
    
     */
    public void serviceIRCTransaction(String from, String hostmask, String command, String destination,String params) {

	if ( hostmask.startsWith(ircNick) ) return;
	if ( command.equalsIgnoreCase("PRIVMSG") )
	    servicePublicMessage(from, hostmask, destination, params.trim());
    }

    /**
     * Process a Public message (PRIVMSG to Channel)
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
    
    params are in the form
    <my nick> :<message> 
    or
    <my nick> <message>	
    
     */
    public void servicePublicMessage(String from, String hostmask, String returnpath,String params) {

	if (!returnpath.startsWith("#")) returnpath = from;
	String lcparams = params.toLowerCase().trim();

	int ccol = params.indexOf(':');
	if ( ccol<0 ) ccol = params.indexOf(' ');

	if ( ccol>1 ) {
	    String token = lcparams.substring(0,ccol).trim();
	    params = params.substring(ccol+1).trim();
	    if ( serviceToken(from, hostmask, returnpath, token,params) ) return;
	} else {
	    if ( serviceToken(from, hostmask, returnpath, lcparams, params) ) return;
	}

	serviceChatter(from,hostmask,params,returnpath);
    }

    /**
     * Process a Token message 
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
    
    params are in the form
    <my nick> :<message> 
    or
    <my nick> <message>	
    
     */
    public boolean serviceToken(String from, String hostmask, String returnpath,String token,String params) {
	System.out.println("token: '" + token + "' params: '" + params + "'");

	if ( token.equals("hello") ) {
	    sendMessage(returnpath, "hello " + from);
	    return true;
	}
	if ( token.equals("time") ) {
	    sendMessage(returnpath, "the time was " + (new Date()).toString());
	    return true;
	}
	if ( token.equals("restart") ) {
	    restartChatterBot();
	    return true;
	}
	if ( token.equals("help") ) {
	    sendHelp(returnpath,params);
	    return true;
	}
	if ( token.equals("echo") ) {
	    sendMessage(returnpath, params);
	    return true;
	}
	if ( token.equals("cyclify") ) {
	    sendMessage(returnpath, toCycListString(params));
	    return true;
	}
	if ( token.equals("paraphrase") ) {
	    if ( params.startsWith("#") ) {
		paraphrased.add(params);
		return true;
	    }
	    sendMessage(returnpath, attemptParaphrase(toCycList(params)));
	    return true;
	}
	if ( token.equals("noparaphrase") ) {
	    paraphrased.remove(params);
	    return true;
	}
	if ( token.equals("subl") ) {
	    serviceSubL(from,returnpath, params);
	    return true;
	}
	if ( token.equals("debug") ) {
	    ircDebug = params;
	    return true;
	}
	if ( token.equals("ask") ) {
	    serviceQuery(from,returnpath, params);
	    return true;
	}
	if ( token.equals("mt") ) {
	    try {
		CycConstant mt = cyc.makeCycConstant(params);
		cyc.assertIsa(mt,cyc.makeCycConstant("#$Microtheory"),cyc.baseKB);
		mtUser.put(from,mt);
	    } catch ( Exception e ) {
	    }
	    return true;
	}
	if ( token.equals("prove") ) {
	    serviceProve(from,returnpath, params);
	    return true;
	}
	if ( token.equals("query") ) {
	    serviceQueryUser(from,returnpath, params);
	    return true;
	}
	if ( token.equals("assert") ) {
	    serviceAssert(from,returnpath, params);
	    return true;
	}

	if ( token.equals("join") ) {
	    ircJoin(params);
	    return true;
	}
	if ( token.startsWith("part") ) {
	    ircPart(params);
	    return true;
	}
	if ( token.startsWith("putserv") ) {
	    ircSend(params);
	    return true;
	}

	if ( servicePlugin( from,  hostmask,  returnpath, token, params) ) return true;

	return false;

    }

    public boolean servicePlugin(String from, String hostmask, String returnpath,String token,String params) {
	return false;
    }

    public void startPlugins() {
	return;
    }

    public void sendHelp(String returnpath, String params) {
	sendMessage(returnpath,"usage: help <hello|time|join|part|ask|query|assert|cyclify>");
    }

    /**
    * Process a SubL command 
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command
    
    params are in the form
    <my nick> :<message> 
    or
    <my nick> <message>	
    
     */
    public void serviceSubL(String cyclist,String returnpath, String subl) {
	try {
	    sendAnswers(returnpath,cyc.converseObject(subl));
	} catch ( Exception e ) {
	    sendMessage(returnpath, ""+ e    /*  + "\" " + " trying to eval \"" + subl + "\" " + "from \"" + cyclist + "\" with returnpath \""+returnpath + "\""*/ );
	}
    }

    /**
    * Process a Query command 
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command

    params are in the form
    <my nick> :<message> 
    or
    <my nick> <message>	

     */

    public void serviceQuery(String cyclist,String returnpath, String query) {
	try {
	    sendAnswers(returnpath, cyc.converseObject( "(cyc-query '" +toCycListString(query) + " #$InferencePSC)"));
	} catch ( Exception e ) {
	    sendMessage(returnpath, ""+ e);
	}
    }
    /**
    * Process a Prove command (Query with proof)
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command

    params are in the form
    <my nick> :<message> 
    or
    <my nick> <message>	

     */
    public void serviceProve(String cyclist,String returnpath, String query) {
	try {
	    sendAnswers(returnpath, cyc.converseObject( "(fi-prove '" +toCycListString(query) + " #$InferencePSC)"));
	} catch ( Exception e ) {
	    sendMessage(returnpath, ""+ e);
	}
    }

    /**
    * Process an Ask command 
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command

    params are in the form
    <my nick> :<message> 
    or
    <my nick> <message>	

     */

    public void serviceQueryUser(String cyclist,String returnpath, String query) {
	try {
	    sendAnswers(returnpath, cyc.converseObject( "(cyc-query '" +toCycListString(query) + " " + mtForUser(cyclist).stringApiValue() + ")"));
	} catch ( Exception e ) {
	    sendMessage(returnpath, ""+ e);
	}
    }

    /**
    * Process an Assert command 
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command

    params are in the form
    assert:<message> 
    or
    <my nick>  <message>	

     */

    public void serviceAssert(String cyclist,String returnpath, String sentence) {
	serviceSubL(cyclist,returnpath, "(cyc-assert '" +toCycListString(sentence) + " " + mtForUser(cyclist).stringApiValue() + ")");
    }

    /**
    * Process an Assert command 
     * @@param destination String nickname of the user who sentence the message
     * @@param message String the command

    params are in the form
    assert:<message> 
    or
    <my nick>  <message>	

     */
    public void serviceChatter(String cyclist,String identity,String message, String returnpath) {
	ircDestination = returnpath;
	return;


	//	try {
	//          if ( chatterBot!=null ) chatterBot.receiveChatMessage(cyclist, cyclist    /*identity hostmask?*/,message);
	//	} catch ( Exception e ) {
	//	    e.printStackTrace(System.out);
	// sendDebug(""+e);
	//	}
    }


    public HashMap mtUser = new HashMap();

    /**
     * Returns a Mt for a user
     */
    public CycFort mtForUser(String cyclist) {

	CycConstant mt = (CycConstant) mtUser.get(cyclist);
	if ( mt==null ) {
	    try {
		mt = cyc.makeCycConstant("#$"+cyclist+"ChatMt");
		cyc.assertIsa(mt,cyc.makeCycConstant("#$Microtheory"),cyc.baseKB);
	    } catch ( Exception e ) {
		mt = cyc.baseKB; 
	    }
	    sendMessage(ircDestination,"Using microtheory" + mt.cyclify() + " for assertions until " + cyclist + " types \"mt <something>\"");
	    mtUser.put(cyclist,mt);
	}
	return(CycFort)mt;
    }


    /**
     * Returns true if Paraphrased for a destination/returnpath
     */
    public boolean isParaphrased(String destination) {
	return( paraphrased.contains(destination));
    }

    /**
     * Cyclifys a sentence a string
     */
    public CycList toCycList(String sentence) {
	try {
	    return(((CycList)((new CycListKifParser(cyc)).read(sentence))));
	} catch ( Exception e ) {
	    return null;
	}

    }
    /**
     * Cyclifys a sentence to a string
     */
    public String toCycListString(String sentence) {
	try {
	    return(((CycList)((new CycListKifParser(cyc)).read(sentence))).cyclify());
	} catch ( Exception e ) {
	    return null;
	}

    }

    public static CycSymbol SYMBOL_NIL = new CycSymbol("NIL");

    /**
     * Sends the Answer message from Cyc to returnpath
     */
    public void sendAnswers(String returnpath, Object results) {
	if ( results instanceof CycSymbol ) {
	    if (results.equals(SYMBOL_NIL)) {
		sendMessage(returnpath,"no answers found");
		return;
	    }
	}
	if ( results instanceof CycList ) {
	    CycList answers = (CycList) results;
	    if ( answers.size()==1 && answers.first().equals(IrcChat.SYMBOL_NIL)) {
		sendMessage(returnpath,"true sentence");
		return;
	    }
	    
	    if ( answers.toString().length()>120 ) {
		if ( answers.size()>50 ) {
		    sendMessage(returnpath,"Your question returned " + answers.size() + " answers .. please refine. (here are the first five)");
		    CycList five = new CycList();
		    for ( int i=0 ; i<5 ; i++ )	five.add(answers.get(i));
		    sendAnswers(returnpath,five);
		    return;
		}
		sendMessage(returnpath,answers.iterator());
		return;
	    }
	}
	sendMessage(returnpath,results);
    }

    public void sendDebug(String message) {
	sendMessage(ircDebug ,message);
    }


    /**
     * Sends the chat message from Cyc into the chat system.
     */
    public void sendChatMessage(String chatMessage) {
       // sendMessage(ircDestination,chatMessage);
    }

    /**
     * Receives chat messages from the user.
     */
    private String receiveChatMessage() throws IOException {
	System.out.print("user> ");
	return "foo";
    }

    public void recievedConsoleMsg(DccClientHandlerThread client,String message) {
	System.out.print("recievedConsoleMsg " + client + ": " + message);
    }

    public void listenForConnections(int port) {
	try {
	    //dccServer = new DccServerThread(this,port);
	    //dccServer.start();
	} catch ( Exception e ) {
	}
    }

    public class DccServerThread extends Thread {
	public boolean listening = true;
	private ServerSocket serverSocket = null;
	private int serverPort = 4444;
	private IrcChat IrcChat = null;
	public HashMap clients = null;

	public DccServerThread(IrcChat ircBot, int port) throws IOException {
	    IrcChat =  ircBot;
	    serverPort = port;
	    clients = new HashMap();
	    serverSocket = new ServerSocket(port);
	    this.start();
	}

	public void run() {
	    try {
		while ( listening ) {
		    Socket thisClient = serverSocket.accept();
		    String username = getLogin(thisClient);
		    DccClientHandlerThread clientThread = new DccClientHandlerThread(IrcChat, thisClient);
		    clientThread.run();
		    clients.put(username,clientThread);
		}

		serverSocket.close();
	    } catch ( Exception e ) {
	    }

	}

	public String getLogin(Socket thisClient) {
	    return thisClient.toString();
	}
    }

    public class DccClientHandlerThread extends Thread {
	private Socket socket = null;
	private IrcChat IrcChat = null;
	private PrintWriter out = null;
	private BufferedReader in = null;

	public DccClientHandlerThread(IrcChat ircBot,Socket socket) {
	    super("DccClientThread");
	    this.socket = socket;
	}

	public void println(String message) {
	    out.println(message);
	}

	public void run() {
	    String inputLine = null;

	    try {
		out = new PrintWriter(socket.getOutputStream(), true);
		in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

		while ( (inputLine = in.readLine()) != null ) {
		    IrcChat.recievedConsoleMsg(this,inputLine);
		}

	    } catch ( IOException e ) {
		e.printStackTrace();
	    }
	}
	public void disconnect() {

	    try {
		out.close();
		in.close();
		socket.close();

	    } catch ( IOException e ) {
		e.printStackTrace();
	    }
	}
    }

}



@


1.4
log
@Removed unused refernces to DCCServerThread
@
text
@d463 1
@


1.3
log
@Removed "I am initializing" message and turned off the use of org.opencyc.chat callback until its completed
@
text
@d30 1
a30 1
    public String ircChannel = "#opencyc";
d39 1
a39 1
    public String ircDestination = "#opencyc";
d59 1
a59 1
    public DccServerThread dccServer;
d64 1
a64 1
    public CycAccess cycAccess = null;
d94 2
a95 4
	cycAccess = access;
	ircConnect();
	start();
	if ( channel!=null ) ircJoin(channel);
d106 1
a106 1
	    ircBot.cycAccess = new CycAccess();
a111 1
	    ircBot.ircConnect();
d155 1
a155 1
	paraphrased.add(ircChannel);
d197 2
d327 1
a327 1
	System.out.println("post = " + post);
d330 1
d338 1
d340 5
a344 3
		return cycAccess.converseString("(generate-phrase " + ((CycConstant)post).stringApiValue() +  ")");
	    //        if ( post instanceof CycFort )
	    //		return cycAccess.converseString("(generate-phrase '" + ((CycFort)post).stringApiValue() +  ")");
d347 1
d349 1
d352 1
d354 4
a357 7
		    return attemptParaphrase(((CycList)post).first()) 
		    + " = " + attemptParaphrase(((CycList)post).rest());
		try {
		    if ( ((CycList)post).first() instanceof CycList ) return attemptParaphrase(((CycList)post).iterator());
		} catch ( Exception e ) {
		    e.printStackTrace();
		}
d359 1
a359 1
		return cycAccess.converseString("(generate-phrase '" + ((CycList)post).stringApiValue() +  ")");
a360 2
	    //          if ( post instanceof CycNart )
	    //		return cycAccess.converseString("(generate-phrase '" + ((CycFort)post).stringApiValue() +  ")");
d384 1
a384 1
	System.out.println(message);
d537 1
a537 1
	if ( token.equals("query") ) {
d543 2
a544 2
		CycConstant mt = cycAccess.makeCycConstant(params);
		cycAccess.assertIsa(mt,cycAccess.makeCycConstant("#$Microtheory"),cycAccess.baseKB);
d554 1
a554 1
	if ( token.equals("ask") ) {
d607 1
a607 1
	    sendAnswers(returnpath,cycAccess.converseObject(subl));
d624 1
d627 1
a627 1
	    sendAnswers(returnpath, cycAccess.converseObject( "(cyc-query '" +toCycListString(query) + " #$InferencePSC)"));
d645 1
a645 1
	    sendAnswers(returnpath, cycAccess.converseObject( "(fi-prove '" +toCycListString(query) + " #$InferencePSC)"));
d665 1
a665 1
	    sendAnswers(returnpath, cycAccess.converseObject( "(cyc-query '" +toCycListString(query) + " " + mtForUser(cyclist).stringApiValue() + ")"));
d722 2
a723 2
		mt = cycAccess.makeCycConstant("#$"+cyclist+"ChatMt");
		cycAccess.assertIsa(mt,cycAccess.makeCycConstant("#$Microtheory"),cycAccess.baseKB);
d725 1
a725 1
		mt = cycAccess.baseKB; 
d746 1
a746 1
	    return(((CycList)((new CycListKifParser(cycAccess)).read(sentence))));
d757 1
a757 1
	    return(((CycList)((new CycListKifParser(cycAccess)).read(sentence))).cyclify());
d824 2
a825 2
	    dccServer = new DccServerThread(this,port);
	    dccServer.start();
a908 2


a909 3



@


1.2
log
@ cyc-query returns (nil), for a tautology (true sentence, without variable bindings)
 cyc-query returns nil for no bindings.

This update recongises this now in sendResponse()
@
text
@d309 1
a309 1
	    return sendMessage(destination,attemptParaphrase((CycList)post));
d805 1
a805 1
	sendMessage(ircDestination,chatMessage);
@


1.1
log
@Joins IRC and allows users to ask queries and make CycL assertions.

Todo:
   Write context help for each command
   More comments in code to improve JavaDoc Generation
   Add Userlevel Microtheory and Inference Settings
   Add to UnitTest


Dependancy: org.opencyc.kif.CycListKifParser();
@
text
@d1 1
d317 3
a319 3
	if ( message.length() > 120 ) {
	    int justify = message.substring(121).indexOf(' ') + 120;
	    ircSend("privmsg " + destination + " :" + message.substring(0,justify));
d540 9
d584 1
a584 1
    
d710 2
d716 11
a726 6
	try {
	    CycConstant mt = cycAccess.makeCycConstant("#$"+cyclist+"ChatMt");
	    cycAccess.assertIsa(mt,cycAccess.makeCycConstant("Microthery"),cycAccess.baseKB);
	    return(CycFort)mt;
	} catch ( Exception e ) {
	    return cycAccess.baseKB; 
d728 1
d762 2
d768 6
d776 5
d910 1
@

