################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
#     ...
#
# Resources for org.datanucleus package (Spanish)
################################################################################
#
# ClassLoader
#
001000=�La clase {0} no esta en el CLASSPATH!. Por favor compruebe la especificaci�n y el CLASSPATH.
001001=PersistenceManagerFactory tiene ClassLoaderResolver de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificaci�n de plugin.
001002=ClassLoaderResolver plugin con clase "{0}" pero no existe! Por favor compruebe el CLASSPATH y especificaci�n de plugin.
001003=ClassLoaderResolver para la clase "{0}" ha dado error en la creaci�n : {1}
001004=�La clase {0} no esta en el CLASSPATH! [ClassResolver llamado por {1} (linea {2})]
001005=�La clase {0} no esta en el CLASSPATH!.
001006=�La clase "{0}" no esta en el CLASSPATH!. Usted tiene que tener "{1}" en el CLASSPATH!

#
# DatastoreIdentity
#
002001=PersistenceManagerFactory tiene datastore-identity de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificaci�n de plugin.
002002=datastore-identity "{0}" usa clase "{1}" pero la clase no existe! Por favor compruebe el CLASSPATH y especificaci�n de plugin.
#
# L1 Cache
#
003001=Cache de nivel 1 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificaci�n de plugin.
003002=Cache de nivel 1 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificaci�n de plugin.
003003=Cache de nivel 1 del tipo "{0}" inicializada
003004=Objeto "{0}" (id="{1}") a�adido a la Cache de nivel 1 (loadedFlags="{2}")
003005=Objeto "{0}" (id="{1}") cambiado en la Cache de nivel 1 (loadedFlags="{2}")
003006=Intenta a�adir a la Cache de nivel 1 un objeto con id nulo. Rechazado.
003007=Objeto con id "{0}" no esta en la Cache de nivel 1 [tama�o = {1}]
003008=Objeto "{0}" (id="{1}") usado de la Cache nivel 1 (loadedFlags="{2}") [tama�o = {3}]
003009=Objeto "{0}" (id="{1}") borrado de la Cache de nivel 1 [tama�o = {2}]
003010=Object "{0}" (id="{1}") no podia ser borrado de la Cache de nivel 1 - no existia
003011=Cache de nivel 1 vaciada.
003012=Objeto "{0}" (id="{1}") va a ser cambiado para ser referenciado por id="{2}" en la Cache de nivel 1
#
# L2 Cache
#
004000=Cache de nivel 2 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificaci�n de plugin.
004001=Cache de nivel 2 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificaci�n de plugin.
004002=Cache de nivel 2 del tipo "{0}" inicializada
004003=Objeto "{0}" (id="{1}") a�adido a la Cache de nivel 2 (loadedFlags="{2}", relationFields="{3}")
004004=Intenta a�adir a la Cache de nivel 2 un objeto con id nulo. Rechazado.
004005=Objeto con id "{0}" no esta en la Cache de nivel 2 [tama�o = {1}]
004006=Objeto "{0}" (id="{1}") usado de la Cache nivel 2 (loadedFlags="{2}", relationFields="{3}") [tama�o = {4}]
004007=Objeto "{0}" (id="{1}") borrado de la Cache de nivel 2 [tama�o = {2}]
004008=Objeto "{0}" (id="{1}") no podia ser borrado de la Cache de nivel 2 - no existia
004009=Cache de nivel 2 vaciada.
004010=Objeto "{0}" (id="{1}") va a ser cambiado para ser referenciado por id="{2}" en la Cache de nivel 2
004011=Intenta almacenar un valor nulo en la Cache. No es posible.
004012=No se puede a�adir el objeto "{0}" a la Cache de nivel 2 porque esta conectado a un PersistenceManager.
004013=Objeto "{0}" (id="{1}") cambiado en la Cache de nivel 2 (loadedFlags="{2}")
004014=Objeto con identidad="{0}") borrado de la Cache de nivel 2 porque ha cambiado pero ha sido GCed [tama�o = {1}]
#
# FetchPlan
#
006000=El campo "{0}" del fetch-group "{1}" no existe en la clase "{2}
006001=Fetch-group "{0}" jerarquizado en el fetch-group "{1}" no existe en la clase "{2}"
006002=El valor {0} no tiene ningun sentido para maxFetchDepth. Usted tiene que poner -1 (no hay limite) o un valor positivo.
006003=No se puede cambiar los raices de detachar antes de commit().
006004=Intenta a�adir el campo "{0}" al fetch group de la clase "{1}", pero el campo no existe en la clase!
#
# Reachability
#
007000=Object "{0}" (id="{1}") estado de vida "{2}" a�adido a la lista de alcanzables al commit.
007001=Haciendo la calculaci�n de alcanzables con el campo "{0}" que es nulo
007002=Haciendo la calculaci�n de alcanzables con el contenedor de SCO al campo "{0}"
007003=Haciendo la calculaci�n de alcanzables en el campo de array "{0}"
007004=Haciendo la calculaci�n de alcanzables en el campo de PC "{0}"
007005=No podremos encontrar el StateManager del objeto de PC "{0}" al campo "{1}" - ignorandolo
007006=El campo "{0}" ha sido seleccionado no usar "persistence-by-reachability" por persistir. No vamos a persistir este campo.
007007=El campo "{0}" va a ser persistido por "persistence-by-reachability".
007008=El campo "{0}" ha sido seleccionado no usar "persistence-by-reachability" por cambio. No vamos a persistir este campo.
007009=El campo "{0}" va a ser cambiado por "persistence-by-reachability".

#
# ObjectManagerFactory
#
008000=DataNucleus Persistence Factory - Vendor: "{0}"  Versi�n: "{1}"
008001=DataNucleus Persistence Factory inicializado para la base de datos URL="{0}" driver="{1}" userName="{2}"
008002=No podemos utilizar DataNucleus Persistence Factory como ya esta cerrado.
008003=No hay ningun adaptador de API "{0}". Usando lo que tenemos ahora mismo
008004=No hay ningun StoreManager del tipo "{0}". Por favor compruebe que usted ha puesto "datanucleus.storeManagerType" correctamente y que todos los plugins necesarios estan en el CLASSPATH
008005=No hay ningun StoreManager para la clave de URL de base de datos "{0}". Por favor compruebe que los plugins existen en el CLASSPATH (datanucleus-rdbms?, datanucleus-db4o?), y piensa de poner la propiedad de persistencia "datanucleus.storeManagerType" al tipo de base de datos que quiere e.g rdbms, db4o
008006=El "implementation creator" de DataNucleus "{0}" no existe en el CLASSPATH. Para utilizar JDO "PersistenceManager.newInstance()" usted tiene que poner DataNucleus Enhancer (y dependencias) en el CLASSPATH.
008007=El "Implementation creator" no esta configurado. Debido a eso usted no puede usar "PersistenceManager.newInstance()"!
008008=El "Implementation creator" {0} esta preparado para usar.
008009=El MetaDataManager para el API "{0}" no esta registrado. Por favor compruebe que el plugin apropiado esta en el CLASSPATH
008010=Error en la creci�n del MetaDataManager para el API "{0}" : {1}
008011=La propiedad {0} ha sido especificada pero no podemos usarla porque la base de datos es de s�lo-lectura
008012=La propiedad "{0}" tiene el valor "{1}" pero el valor no es v�lido. Por favor consulte la documentacion para ver la lista de valores correctos.
008013=El archivo de propiedades "{0}" leemos antes. Vamos a ignorar el archivo de propiedades "{1}"
008014=No se puede leer el archivo de propiedades "{0}"
008015=Propiedad {0} desconocida - vamos a ignorarla
008016=Cambios en la configuraci�n no son posible despues de generar un manager de persistencia
#
# Connections
#
009000=La Connecci�n ha sido reservado por usted y debe cerrarla antes de usar operaciones del API.
009001=La factor�a de conexiones ({0}) no est� soportada - debe ser un javax.sql.DataSource
009002=La factor�a de connecciones "{0}" no existe o no se encuentra disponible
009003=Ya existe una conexi�n a la base de datos - quizas un Query siga ? La especificacion de JDO secci�n 12.6 dice que un PersistenceManager puede usar solamente una connecci�n a la base de datos en un momento. Si usted quiere hacer otras operaciones, debe usar m�s PersistenceManagers.
#
# ObjectManager
#
010000=Object Manager "{0}" se abri� para la base de datos "{1}"
010001=Object Manager "{0}" se cerr�
010002=Object Manager ya esta cerrado
010003=ObjectManager proceso internalFlush() empezado - {0} objetos sucios
010004=ObjectManager proceso internalFlush() terminado
010005=Intento de obtener un objeto nondurable en estado HOLLOW por getObjectById!
010006=No hay ningun objeto nondurable con este identidad en el cache - �quizas de otro Manager?
010007=Objeto con id "{0}" es manejado por otro ObjectManager
010008=Objeto no es detachado. Esta operaci�n le hace falta un objeto en este estado
010009=Haciendo el objeto detachado : "{0}" (profundidad={1})
010010=Detachando una copia del objeto : "{0}" (profundidad={1}) : va a ser "{2}"
010011=DetachOnClose : Cerrando Manager asi que haciendo detach con todos los objetos corrientes ...
010012=DetachOnClose : detach terminado
010013=No es posible detachar el objeto "{0}" (id="{1}") al cometer como ya no existe en la base de datos. Quizas haya una clave ajena que lo ha borrado
010014=No se puede usar detachCopy() fuera de una transacci�n cuando haya instancias en el estado "transient" alcanzable
010015=Haciendo el objeto persistente : "{0}"
010016=Haciendo el objeto persistente (adjuntar) : "{0}"
010017=Intento de adjuntar "{0}" a persistencia pero otro objeto persistente con la misma identidad ya existe para esta transaccion!
010018=Haciendo el objeto persistente (adjuntar) : "{0}" - adjuntando para ser "{1}"
010019=Borrando el objeto de persistencia : "{0}"
010020=No fu� posible borrar objetos transitorios.
010021=No fu� posible borrar objetos transitorios transaccional. Identidad de objeto = {0}
010022=Haciendo el objeto transitorio : "{0}"
010023=Objeto "{0}" (id="{1}") no es transaccional
010024=No fu� posible cambiar el estado de objetos entre sucio transitorio y non-transaccional
010025=No fu� posible cambiar el estado de objetos entre transitorio y non-transaccional
010026=Objeto no existe
010027=El objeto con id "{0}" no ha sido encontrado
010028=No fu� posible crear una identidad de objeto por una clase que es nulo!
010029=No fu� posible crear una identidad de objeto por la clase "{0}" porque el tipo de clave no esta soportada ({1})
010030=Ocurri� un error durante la construcci�n de una instancia de Id de tipo "{0}" por la clase abstracta "{1}"
010031=Algunos objetos han fallado de commit() debido a problemas de verificaci�n optimista.
010032=Haciendo la comprobaci�n de "persistence-by-reachability" (commit) ...
010033=El objeto con identidad "{0}" se almacen� con una llamada a makePersistent() pero ya no esta accesible. Vamos a borrar el objeto de la base de datos.
010034=Ha terminado la comprobaci�n de "persistence-by-reachability" (commit).
010035=Cannot perform operation since ImplementationCreator doesnt exist in the CLASSPATH (put datanucleus-enhancer.jar in the CLASSPATH).
010036=No fu� posible desahuciar algunos de los objetos
010037=No fu� posible refrescar algunos de los objetos
010038=No fu� posible recuperar algunos de los objetos
010039=No fu� posible hacer persistente algunos de los objetos
010040=No fu� posible borrar algunos de los objetos
010041=No fu� posible hacer transitorio algunos de los objetos
010042=No fu� posible hacer transaccional algunos de los objetos
010043=No fu� posible hacer non-transaccional algunos de los objetos
010044=No fu� posible encontrar el objeto con identidad nulo!!

010050=Intento de empezar una transaccion optimistica pero StoreManager para este base de datos no soporte optimistic locking! Elige "datanucleus.Optimistic" como falso.
010051=Intento de persistir un objeto con datastore-identity pero StoreManager para este base de datos no soporte ese identity type
010052=Intento de persistir un objeto con application-identity pero StoreManager para este base de datos no soporte ese identity type

#
# Managed Relationships
#
013000=Manejar de relaciones : empezando
013001=Manejar de relaciones : terminado
013002=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a "{4}". Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013003=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a nulo. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013004=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" que ya tiene valor de "{2}" pero ya ese objeto va a relacionar con "{3}" asi que ponemos nulo en el campo
013005=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido cambiado para relacionar con este objeto, asi que cambiando nuestra relacion para estar de acuerdo
013006=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" con el campo "{2}" del objeto "{3}" pero ya no estan relacionados. Quitandolo del contenedor
013007=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" con el campo "{2}" del objeto "{3}" y debe estar en el contenedor pero no esta. A�adiendolo
013008=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido a�adido, pero ese objeto ya este en estado borrado!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013009=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido a�adido, pero tiene su due�o como "{3}"!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013010=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido borrado, pero tiene este objeto como su due�o!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"

#
# Transactions
#
015000=Transacci�n empezada para el ObjectManager {0} (optimistic={1})
015001=Haciendo commit de la transaacci�n para el ObjectManager {0}
015002=Haciendo rollback de la transacci�n para el ObjectManager {0}
015003=Transacci�n empezada para la connection {0}
015004=La ransacci�n no se pudo comenzar
015005=La ransacci�n no se pudo flush
015006=Haciendo commit de la transacci�n para la connexi�n {0}
015007=No se puedo hacer commit de la transacci�n
015008=Haciendo rollback de la transacci�n para la connexi�n {0}
015009=Transaccion ha fallado de restaurar
015010=El modo Non-transaccional Write no est� soportado
015011=El modo Optimistic no est� soportado
015012=Nivel de aislamiento no es v�lido : {0}
015013=La connexi�n {0} empez� para una transacci�n pesimista
015014=La connexi�n {0} termin� para una transacci�n pesimistac
015015=La connexi�n {0} empez� para una transacci�n optimista
015016=La connexi�n {0} termin� para una transacci�n optimista
015017=Objeto "{0}" (id="{1}") ha sido puesto en la cache transaccional
015018=Objeto "{0}" (id="{1}") puesto en la cache transaccional ya esta referenciado por id="{2}"
015019=Objeto "{0}" (id="{1}") va a ser borrado de la cache transactional
015020=Transacci�n es "rollback-only", asi que no se puede hacer commit en este estado.
015021=No se pudo obtener una connexi�n.
015022=Transacci�n committed en {0} ms
015023=Transacci�n rolled back en {0} ms
015024=El uso de transacciones de JTA necesita una datasource manejado como tiene dependencia al TransactionManager para cometer las connecciones.
015025=Ya hemos asynchronisado con la transacci�n de JTA, pero hemos recibido otro pedido hacerlo!
015026=Transacci�n de JTA pero hemos recibido un error buscando la transacci�n de JTA.
015027=Transacci�n de JTA esta marcado por rollback, quizas un timeout. Cualquier otra operaci�n que necesita accesso a la base de datos va a fallar.
015028=Error intentando obtener el estado de la transacci�n de JTA!
015029=Transacci�n de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrar el NamingService. Por favor compruebe su configuraci�n
015030=Transacci�n de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrarlo (solo apoyamos WebLogic y JBoss)
015031=Una transacci�n de la base de datos ha sido restaurada, pero se lanzaron las siguientes excepciones durante la transici�n del estado de los objetos de JDO
015032=La transacci�n ya est� activo.
015033=La transacci�n ya est� activo.
015034=La transacci�n est� activo todavia. Debe cerrar las transacciones usando los m�todos commit() o rollback().
015035=La transacci�n no est� activo. Tiene que poner este en una transacci�n o usar su PersistenceManagerFactory con 'NontransactionalRead' y 'NontransactionalWrite' como 'true'
015036=Se est� haciendo commit o rollback de la transacci�n. Esta operaci�n no esta disponible en este momento.
015037=Una transacci�n de base de datos ha sido acometida, pero se lanzaron las siguientes excepciones durante la transici�n del estado de los objetos de JDO
015038=Operation {0} failed on resource: {1}, error code {2} and transaction: {3}
015039=Running {0} operation on resource: {1}, error code {2} and transaction: {3}
015040=La transacci�n no est� activo. Tiene que poner este en una transacci�n.
015041=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalRead' puesto. Usted no tiene ninguna de los dos.
015042=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalWrite' puesto. Usted no tiene ninguna de los dos.
015043=Este base de datos no soporte el nivel de isolacion de transacciones "{0}"

#
# Types
#
016000=Soportando el tipo de Java {0} (persistent={1}, DFG={2}, embedded={3})
016001=Soportando el tipo de Java {0} como el tipo de Java {1}
016002=Excepcion tirada en la conversion de "{0}" a un objeto del tipo "{1}"
016004=La clase de mapping "{0}" no existe o no es encuentra. Por favor, compruebe la especificaci�n de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
016005=La clase de SCO "wrapper" "{0}" no existe o no es encuentra. Por favor, compruebe la especificaci�n de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
#
# Sequence
#
017000=No hemos encontrado la secuencia "{0}". Por favor compruebe que existe en un archivo de Meta-Data.
017001=No hemos encontrado el factory-class "{0}" por la secuencia "{1}". Est� en el CLASSPATH ?
017002=Ocurri� un error durante la invocacion de metodo newInstance() en el factory-class "{0}" : {1}
017003=La secuencia "{0}" ya existe y usa el generador "{1}"
017004=La secuencia "{0}" no tiene valores asignados. Por favor llame primero a "allocate(int)" para asignar los valores.
017005=La secuencia "{0}" no genera valores num�ricos. Por favor llame a "next()" para obtener el valor como un Objeto.
017006=Error durante el proceso obtener la conexi�n por la generaci�n de valor : {0}
017007=Error durante el proceso cerrar la conexi�n por la generaci�n de valor : {0}
#
# Exceptions
#
018000=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data/Annotaciones de la clase no existe o no se encuentra disponible.
018001=No hemos encontrado el Meta-Data/annotaciones para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML correcto y v�lido.
018002=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data de la clase no existe o no se encuentra disponible.
018003=No hemos encontrado el Meta-Data para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML para JDO correcto y v�lido.
018004=La clase "{0}" no es Detachable. Este significa que el MetaData de la clase no incluyo el atributo "detachable" como "true".
018005=Algunos de los objetos no son de clases que son Detachable. Este significa que el MetaData de las clases no incluyo el atributo "detachable" como "true". Las excepciones adjuntas tienen los detalles de los objetos.
018006=El objeto de tipo "{0}" esta detachado. �No se puede utilizar objetos detachados con esta operaci�n!
018007=La clase persistente no tiene un Extent (definido en el Meta-Data) : {0}
018008=El campo "{0}" contiene un objeto que no esta persistente pero el campo no permite persistencia por cascada.
018009=El campo "{0}" no existe en {1} o no es persistente
018010=El campo #{0} no existe en {1} o no es persistente
019000=La clase {0} ha sido definido con el object-id class {1} que es "inner" pero no es estatica. El ObjectId class debe ser estatica si es "inner".
#
# Primary Key
#
019001=La clase {0} ha sido definido con el object-id class {1} que no es publico. El ObjectId class debe ser publico.
019002=La clase {0} ha sido definido con el object-id class {1} que no es Serializable. El ObjectId class debe ser Serializable.
019003=La clase {0} que utilisa la clase de identidad de JDO SingleFieldIdentity, pero hay mas que un campo con primary-key para la clase. Se puede elegir solo un campo como primary-key
019004=La clase {0} ha sido definido con el object-id class {1} que no tiene constructor defecto. Todos los objectId classes deben tener un constructor defecto.
019005=La clase {0} ha sido definido con el object-id class {1} que no tiene un constructor de String. Todos los objectId classes deben tener un constructor de String.
019006=La clase {0} ha sido definido con el object-id class {1} que no define el metodo toString(). Todos los objectId classes deben definir el metodo toString().
019007=La clase {0} ha sido definido con el object-id class {1} que no define el metodo hashCode(). Todos los objectId classes deben definir el metodo hashCode() para utilizar todos los campos de la clave primaria.
019008=La clase {0} ha sido definido con el object-id class {1} que no define el metodo equals(). Todos los objectId classes deben definir el metodo equals() para utilizar todos los campos de la clave primaria.
019009=La clase {0} ha sido definido con el object-id class {1} que tiene el campo {2} que no es Serializable. Todos los campos non-estaticos del objectId class deben ser Serializable.
019010=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2} que no es publico. Todos los campos non-estaticos de un objectId class deben ser publico.
019011=La clase {0} utilisa la clase de identidad {1}que tiene un campo {2}, pero el campo no existe en la clase {0}.
019012=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} que es persistence-capable. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019013=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} pero debe ser {4}. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019014=Class {0} has been specified with an object-id class {1} which has a field {2}. The field {1}.{2} has type {3} that must be specified in the metadata /jdo/package/class/@objectid-class attribute for type {4}. e.g <class name="{4}" objectid-class="{3}"/>
019015=La clase {0} ha sido definido con el object-id class {1} que tiene {2} campos, mientras la clase ha sido definido con {3} campos en el "primary-key". El numero de campos en el objectidClass y el numero en el "primary-key" deben ser lo mismo.
019016=Invalid primary key class {0}.
020000=La clase "{0}" no tiene una tabla en la base de datos, pero esta operacion la necesita. Por favor compruebe el MetaData
020001=El campo no tiene una columna en el base de datos : {0}
020002={0} no puede ser referenciado en una expression de tabla basado en {1} porque no existe ninguna uni�n a su tabla, {2}

#
# Query
#
021000=Tipo de par�metro incompatible : era {0}, pero debe ser {1} o una subclase
021001=El Query de JDOQL ha vuelto m�s que una instancia pero "unica" esta "verdad" o hay solo aggregados asi que debe devolver una como maxima.
021002=La declaraci�n del import no es valido : {0}
021003=La declaraci�n del package import no es valido : {0}
021004=La declaraci�n del class import es duplicado : {0}
021005=La clase de los imports no existe : {0}
021006=Almacenando el hecho de que {0} no fuera encontrado por {1}
021007=Los tipos de Array son illegal : {0}
021008=Hay ambiguedad en la declaraci�n de la clase ; puede ser {0} o {1}

021010=La clase {0} ha sido resuelto a {1}. Usted no la puso completamente en el Query y por eso podria evitar en look-up (y mejorar el rendimiento) si la ponga con nombre de paquete etc.
021011=Intento de invocar el metodo "{0}()" del objeto de tipo "{1}" - no lo apoyamos con este base de datos
021012={1} Query : Procesando la clausula "{0}" con evaluacion en memoria (clausula = "{2}")
021013=El Manager del Query esta cerrado!
021014=Esta Query no se puede cambiar. No puede cambiar su estructura.
021015=Query contiene nombre de una clase "{0}" (clase de candidato, clase de resultado, parametro, o variable) pero no esta resuelto. Por favor, compruebe el nombre y los imports.
021017=Query no tiene un Manager

021018=La ejecuci�n del query "{0}" no ha completado antes que el timeout de {1}ms
021019=El query "{0}" empiece en un su propio hilo con el timeout de {1}ms
021020=El query "{0}" ha sido cancelado
021021=Un error ha ocurrido durante la ejecuci�n del query "{0}"
021022=El query "{0}" empiece en un su propio hilo sin timeout

021027=Query tiene que borrar objetos, pero hay un orden. No se puede poner el orden si es para borrar instancias.
021028=Query tiene que borrar objetos, pero hay un grupo. No se puede poner el grupo si es para borrar instancias.
021029=Query tiene que borrar objetos, pero el resultado existe. No se puede poner el resultado si es para borrar instancias.
021030=Query tiene que borrar objetos, pero la clase de resultado existe. No se puede poner la clase de resultado si es para borrar instancias.
021031=Query tiene que borrar objetos, pero tiene alcance de resultado. No se puede poner el alcance de resultado si es para borrar instancias.
021032=Query tiene "unique", pero el resultado contiene m�s que un objeto. No se puede poner "unique" si hay m�s que un objeto por ser borrado.
021043=Error con la extracci�n de resultados por el Query "{0}"

021044=Query de {0} : Compilaci�n de "{1}"
021045=Query de {0} : Tiempo de compilar = {1} ms
021046=Query de {0} : Ejecucion de "{1}" ...
021047=Error en la ejecucion de Query de {0} - "{1}" : {2}.
021048=No hay una clase de candidato por el Query de {0}
021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021050=El filtro de Query "{1}" no da un resultado de boolean
021051=La expresi�n de "HAVING" "{0}" no es valido. Debe ser una expresi�n Boolean.

021053=La clase "{0}" en una expresi�n (cast) no existe. Por favor compruebe que la clase esta en el CLASSPATH y esta en los imports del Query.

021054=El Query de {0} contiene una expresi�n invalida
021055=Query tiene algunas parametros declarados ("{0}"), pero hay por lo menos un parametro implicito ("{1}"). Es invalido. Usted debe declarar todos los parametros (explicito), o usar todos los parametros con un prefix :.
021056=Query tiene un par�metro implicito "{0}" (en posici�n {1}) �pero no hab�a un valor disponible para esta posici�n!

021057=El uso de "new" en {0} debe seguir con el nombre de la clase, pero {1} no existe. Por favor, compruebe la lista de "imports".
021058=El uso de "new" en {0} debe seguir con el nombre de la clase y los argumentos del constructor pero esta incorrecta en "{1}".

021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021060=Error conectando el variable "{0}" a "{1}" como estaba conectado a "{2}" antes.
021061=El variable "{0}" no esta conectado al Query de JDOQL.
021064=The range {0} expression accepts only Literal values. Either define it as parameter or a literal. The current value is {1}.
021065=The range {0} expression expects a number, but it currently is {1}.
021066=No era posible encontrar la clase "{0}". Por favor, compruebe que la clase existe en el CLASSPATH.
021068=El parametro de Query ("{0}") esta conectado a otro Manager. Es imposible usar este Query asi.
021069=El "ORDER BY" tiene una expresi�n de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "ORDER BY" tiene que estar tambien en el "GROUP BY".
021070=El resultado tiene una expresi�n de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el resultado tiene que estar tambien en el "GROUP BY".
021071=El "HAVING" tiene una expresi�n de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "HAVING" tiene que estar tambien en el "GROUP BY".
021051=La expresi�n de "HAVING" "{0}" no es valido. Debe ser una expresi�n Boolean.
021072=Collecci�n de candidatos esta vacia!
021073=Extent de candidatos esta vacia!
021074=Query de {0} : Tiempo de ejecutar = {1} ms
021079=Query "{0}" de lenguaje "{1}" existe, por eso utilizamos la compilacion general de antes.
021080=Query "{0}" de lenguaje "{1}" para la base de datos "{2}" existe, por eso utilizamos la compilacion de datastore de antes

# Query : Parameters/Variables
021101=Query tiene una lista de parametros que esta incorrecta "{0}"
021102=Query tiene un parametro "{0}" que esta incorrecta
021103=Query tiene dos o mas parametros con nombre "{0}"
021104=Query tiene una lista de variables que esta incorrecta "{0}"
021105=Query tiene un variable "{0}" que esta incorrecta
021106=Query tiene un variable "{0}" que es lo mismo que un parametro
021107=Query tiene dos o mas variables con nombre "{0}"
021108=Query hace falta {0} parametros, pero tiene {1}.
021109=The parameter {0} expected the argument value of primitive type {1}.
021110=El Query de {0} hace falta un parametro "{1}" pero no esta
021111=Query tiene algunas variables declarados ("{0}"), pero hay por lo menos un variable implicito ("{1}"). Es invalido. Usted debe declarar todos los variables explicito, o usar todos los variables como implicito.
021112=Query contiene un parametro "{0}" pero no hay ningun valor especificado al ejecutar el Query!
021113=Query tiene un valor por el parametro "{0}" pero este parametro no existe en el Query!
021114=Query tiene parametro "{0}" como un {1} pero esta comparado con un {2}. Los valores de parametros deben ser consistente con lo que se compare.
021115=Query tiene un subquery pero no hay declaracion de variables! Un subquery tiene que pasar su valor al Query principal por un variable
021116=Query tiene el parametro "{0}" provisto al ejecucion pero este query no lo utiliza!

# Query : Result
021201=El Query va a volver con mas que un campo pero la clase de resultado es de un tipo simple ({0}). Son inconsistentes.
021202=El Query va a volver con un campo pero no es de la clase de resultado ({0}) : es {1}
021203=El Query tenia que devolver objetos de tipo "{0}" pero era imposible. Por favor compruebe que esta clase esta corecta por JDO.
021204=El Query tenia que devolver objetos de tipo "{0}" pero era imposible poner el valor al campo "{1}"  tipo "{2}". El campo debe tener un metodo publico set/put o ser publico.
021205=El Query tenia que devolver objetos de tipo "{0}" pero era imposible crear nueva instancia de este tipo! La clase de resultado necesita un constructor sin argumentos.
021206=La clase de resultado "{0}" no tiene un constructor con arguments de tipos {1}
021207=La clase de resultado "{0}" no tiene un metodo publico "void {1}({2})".
021208=La clase de resultado"{0}" no tiene un metodo publico "void {1}(Object, Object)".
021209=La clase de resultado "{0}" no tiene un campo publico "{1}"
021210=La clase de resultado no permite nombres de campos en mayusculos o menusculos; tiene que ser escrito corecto. Por ejemplo, el campo "{0}" esta mal escrito.
021211=El query tiene campo de resultado "{0}" de tipo "{1}" pero el tipo en la clase de resultado es "{2}"!
021212=El query tiene clase de resultado "{0}" pero no hay ninguna manera de poner el campo "{1}"!

# Query Cache
021500=Cache de Query "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificaci�n de plugin.
021501=Cache de Query "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificaci�n de plugin.
021502=Cache de Query del tipo "{0}" inicializada

#
# Api Adapter
#
022000=Error : Un error ocurrio cuando creando un adaptador "{0}" : {1}
#
# SCO
#
023000=El tipo de par�metro solicitado por el campo "{0}" : era {1} pero debe ser {2}
023001=El campo {0} no puede ser nulo en objeto "{1}"
023002=El contenedor (Collection/Map) no es preguntable como no tiene due�o que es un objeto de primera clase
023003=Creado SCO wrapper por objeto "{0}" campo "{1}" con {2} valores, con las opciones="{3}"
023004=El objeto "{0}" campo "{1}" ha sido reemplazado por un SCO wrapper de tipo "{2}" {3}
023005=El objeto "{0}" campo "{1}" enviando cambios del contenedor de SCO a la base de datos
023006=El objeto "{0}" campo "{1}" obteniendo los contenidos al contenedor de SCO de la base de datos
023007=El objeto "{0}" campo "{1}" va a ser inicializado por un contenedor con {2} valores
023008=El objeto "{0}" campo "{1}" va a ser cambiado por un conteneder con {2} valores
023009=Es imposible persistir el objeto "{0}" como esta manejado por otro Object Manager
023010={0} no es un tipo valido de SCO por campo {1}, deb ser compatible con {2}
# needs updating
023011=La clase {0} no es apoyado como objeto de clase segundo (SCO)
023012=El campo "{0}" debe usar un comparator de clase "{1}" pero esa clase no existe en el CLASSPATH. Por favor compruebe el nombre de la clase de comparator.
023013=Execuci�n del metodo "{0}" en el campo "{1}" ha causado un error : {2}
#
# Plugin
#
024000=File {0} doesn't exist. Check your path or classpath.
024001=Error reading plug-in file {0} : {1}
024002=Extension Point "{0}" not registered, but plugin "{1}" defined in {2} refers to it.
024003=Loading extension points from plug-in file {0}.
024004=Loading extensions from plug-in file {0}.
024005=Plugin Registry "{0}" no existe. Usando registry de DataNucleus
024006=Plugin Registry "{0}" no existe. Usando registry de DataNucleus. Reason : {1}.
024007=Error en la registraci�n del Bundle como el URL al MANIFEST.MF es nulo
024008=Error en leer el manifest "{0}"
024009=El plugin (Bundle) "{0}" ya esta registrado. Por favor compruebe que usted no tiene otras versiones del mismo plugin en el CLASSPATH. El URL "{1}" esta registrado, y intenta registra otro al URL "{2}."
024010=Error en la creaci�n del URL para el plugin MANIFEST "{0}"
024011=Error en leer el MANIFEST.MF for "{0}"
024012=No se puede encontrar el fichero MANIFEST.MF para el plugin "{0}". Vamos a ignorarlo
024013=Bundle "{0}" tiene una dependencia opcional a "{1}" pero no se puede resolverla
024014=Bundle "{0}" se hace falta "{1}" pero no se puede resolverla
024015=Bundle "{0}" se hace falta "{1}" versi�n "{2}" pero ese bundle tiene versi�n "{3}" que esta fuera de los versiones aceptadas.
024016=Error en la creacion del DocumentBuilder : {0}
#
# CallbackHandler
#
025000=Error : Un error ocurrio cuando creando un CallbackHandler "{0}" : {1}
025001=Una excepcion ha sido tirado por el callback del usuario "{0}".
#
# StateManager
#
026000=No hay bastante acceso a org.datanucleus.*
026001=Desconectando del clono {0} de {1}
026002=El campo {0} de la clase {1} no existe
026003=Cambiar el StateManager da un error
026004=Desconectar el StateManager da un error
026005=Vaciando el StateManager de {0}
026006=El metodo no es apoyado
026007=No es posible compartir SCO's con due�os; objeto do�ado por campo {0} del objeto {1}
026008=Recurrente llamada a deletePersistent()
026009=Recurrente llamada a flush()
026010=Objeto tiene el estado �sucio�� pero �no hay campos sucios!
026011=Disconectando {0} de {1}
026012=No puede persistir la clase {0}
026013=Objeto no existe (identidad="{0}")
026014=La clase "{0}" del objeto con id "{0}" na ha sido encontrado
026015=La clase {0} no esta ! Por favor, comprueba usted que la clase existe en el CLASSPATH.
026016=The primary-key field {0} is null.
026017=Un objeto de la clase "{0}" usa SingleFieldIdentity con el campo "{1}" pero el campo no tiene ningun valor! Usted debe poner un valor, o usa "value-strategy" con este campo.
026018=La clase "{0}" no ha sido registrada. Por favor compruebe que esta analizada.
026019=No podemos crear una instancia de la clase "{0}". Si es "abstract", usted tiene que comprobar que no hay una fila por esa clase en la base de datos sin una fila en la tabla de una subclase.
026020=El campo "{0}" tiene value-strategy de "{1}" pero el tipo del campo no esta correcta usarlo.
026021=El campo "{0}" del objeto "{1}" ha sido registrado para actualizaci�n cuando su valor PC esta en la base de datos.
026022=Vamos a actualizar el valor del campo "{0}" del objeto "{1} como su valor PC ya esta en la base de datos.
026023=No podemos "detach" al objeto de tipo "{0}" y con identidad "{1}" porque ha sido borrado!
026024=No podemos "detach" el objeto de tipo "{0}" y con identidad "{1}" porque ya es "detached"!
026025=El "detach" del objeto de tipo "{0}" y con identidad "{1}" ha fallado. Por favor, compruebe el Log para alguna detalle.
026026=Vamos a borrar el objeto "{0}" porque esta el valor en un campo ({1}) donde el valor has sido anulado y el campo es delete-dependent.
026027=Una transition ilegal "{0}" ha sido intentado desde el estado "{1}", sm = "{2}"
026028=El objeto "{0}" ha sido marcado para persistir pero vamos a persistir a la base de datos mas tarde debido a transacci�n optimistic o "delayDatastoreOperationsUntilCommit"
026029=El objeto "{0}" (id="{1}") va a tener el valor en el campo "{2}" cambiado por un SCO wrapper
026030=El objeto "{0}" (id="{1}") va a tener el SCO wrapper en el campo "{2}" cambiado por el valor026031=Object "{0}" (id="{1}") is to be detached (using DetachAllOnCommit?) but is not detachable, so being made transient
026031=El objeto "{0}" (id="{1}") va a ser detachado (con la opcion DetachAllOnCommit?) pero no es detachable, por eso vamos a hacerlo transient
026032=El objeto "{0}" (id="{1}") tiene una valor cargado en campo {2} que esta fuera del FetchPlan. Descargandolo.
026033=El objeto "{0}" (id="{1}") va a tener los campos siguientes cargados del objeto de L2 cache : {2}
#
# LifeCycle states
#
027000=No se puede leer los campos fuera de una transacci�n. Used debe pensar en poner 'NontransactionalRead=true'.
027001=No se puede escribir los campos fuera de una transacci�n. Used debe pensar en poner 'NontransactionalWrite=true'.
027002=No se puede leer los campos fuera de una transacci�n. Used debe pensar en poner 'NontransactionalRead=true'.
027003=No es posible cambiar el estado del objeto a nontransaccional como es nuevo, borrado y no esta comitido
027004=No es posible cambiar el estado del objeto a transitorio como es nuevo, borrado y no esta comitido
027005=No es posible leer campos de un objeto borrado
027006=No es posible escribir campos de un objeto borrado
027007=No es posible cambiar el estado del objeto a nontransaccional como esta borrado
027008=No es posible cambiar el estado del objeto a transitorio como esta borrado
027009=No es posible leer campos de un objeto borrado
027010=No es posible escribir campos de un objeto borrado
027011=No es posible cambiar el estado del objeto a nontransaccional como es sucio
027012=No es posible cambiar el estado del objeto a transitorio como es sucio
027013=No es posible cambiar el estado del objeto a nontransaccional como no es nuevo y no esta comitido
027014=No es posible cambiar el estado del objeto a transitorio como es nuevo y no esta comitido
027015=El campo no esta copiado al objeto "detached". Usted tiene que a�adirlo al FetchPlan y "detach" el objeto otra vez.
027016=Objeto "{0}" (id="{1}") tiene cambio de lifeycle : "{2}"->"{3}"
#
# XML Parser
#
028000=XML Entity Public="{0}" System="{1}" : con source local "{2}"
028001=XML Entity Public="{0}" System="{1}
028002=resolveEntity({0}, {1}) no existe
028003=resolveEntity({0}, {1}) ha fallado!
#
# SingleFieldIdentity
#
029000=No era posible construir una identidad de SingleFieldIdentity de tipo "{0}" porque la clase dado es nulo
029001=El tipo de identidad para construir una identidad de SingleFieldIdentity para la clase "{0}" es nulo
029002=El tipo de identidad ("{0}") dado para construir una identidad de SingleFieldIdentity para la clase "{1}" no es valido.
029003=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" para la clase "{1}" es nulo.
029004=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" de la clase "{1}" es de un tipo invalido ("{2}") - debe ser "{3}".
#
# Utils
#
030000=Todavia espero el read lock por {0}
030001=Ya el Thread tiene un read lock
030002=Todavia espero el write lock por {0}
030003=El formato de Timestamp no esta mal: "{0}" - debe ser yyyy-mm-dd hh:mm:ss.fffffffff
030004=Un constructor de la clase {0} no existe, parametros {1} 
030005=Error cuando intentando usar la clase {0}
030006=Error intentando crear un objeto de la clase {0}
030007=Excepcion tirado por constructor por {0}, {1}
#
# RDBMS Views/Macros
#
031000=Incomparable puntales para el macro de interrogacion: {0}
031001=Incomparable punto de interrogacion para el macro de parametro: {0}
031002=No puede parsar macro de identificacion: {0}
031003=Hay una dependencia circular entre las visiones

#
# Store Manager
#
032000=No hay un StoreManager disponible : {0}
032001=Va a manjejar la persistencia de {0}
032002=Desmanejando la persistencia de todas las clases
032003=Manejando la persistencia de {0} porque era manejado antes

032004=Intenta de poner objeto "{0}" en una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de PersistenceManagerFactory "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032005=Intenta de poner objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032006=Intenta de cambiar objeto "{0}" en una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de PersistenceManagerFactory "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032007=Intenta de cambiar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032008=Intenta de borrar objeto "{0}" de una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de PersistenceManagerFactory "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032009=Intenta de borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032010=Intenta de borrar objeto "{0}" dependiente de objeto en una base de datos que es para leer
032011=Intenta de borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.

032012=La clase "{0}" es "embedded-only" asi que no tiene su propia tabla.
032013=La clase "{0}" usa la estrategia "subclass-table" y no hay una subclase o superclase que tiene una tabla.
032014=La clase "{0}" usa la estrategia {1} y no hemos encontrado una tabla para persistirla.
032015=Intenta obtener el nombre de la tabla de base de datos por una clase nula !

032013=La clase {0} usa estrategia de "subclass-table" pero ningun subclase tiene una tabla definida.

032016=Objeto "{0}" (id="{1}") ha sido cambiado en la base de datos despu�s de la ultima leer. Base de datos tiene version "{2}" pero la transacci�n tiene version "{3}"
032017=La clase "{0}" tiene estrategia de versiones de "{1}" pero JPOA no la apoya ahora mismo. Por favor compruebe la documentaci�n para las estrategias que apoyamos.

032018=Registrado la factoria de connecciones transaccionales bajo el nombre "{0}"
032019=Registrado la factoria de connecciones nontransaccionales bajo el nombre "{0}"

032020=StoreManager : "{0}" con el URL "{1}" - opciones={2}, {3}

#
# Extent
#
033000=No se puede crear el Extent porque tiene que dar el nombre de la clase.
033001=No se puede crear el Extent de la clase "{0}" porque no hay Meta-Data disponible para esa clase.
033002=El Extent de {0} incluso los subclases={1}
033003=Query sobre Extent nunca va a dar resultado sin subclases : extent= {0}, clase={1}

#
# Auto Starter
#
034000=Error en la inicialisaci�n de DataNucleus : Una clase "{0}" estaba en la lista de persistencia de este esquema pero no la existe. Quizas es de otra aplicaci�n de DataNucleus usando la misma esquema, o has cambiado los nombres de las clases.
034001=Borrando la clase {0} de la lista de clases manejadas
034002=Unknown Error during auto starter execution. : {0}
034003=Illegal state of AutoStart, disabling it. To enable it, resolve earlier errors.
034004=Error en la inicialisaci�n de DataNucleus: una clase "{0}" estaba en la lista de persistencia de este esquema pero ya no tiene MetaData disponible.

034100=Mecanismo de AutoStart con clases. Tiene que poner una lista de clases en la construcci�n del PMF.
034150=Mecanismo de AutoStart con MetaData. Tiene que poner una lista de archivos de MetaData en la construcci�n del PMF.

034200=Mecanismo de AutoStart de XML. Almacena su definici�n en un fichero de XML
034201=El fichero de XML AutoStarter {0} no existe. Creandolo ...
034202=Error leer el fichero de XML AutoStart {0} : {1}
034203=Error escribir el fichero de XML AutoStart {0} : {1}
034204=resolveEntity({0}, {1})

#
# Store Data
#
035000=El MetaData no puede ser nulo : tabla = {0}
035001=La tabla no puede ser nulo
035002=Clase : {0}
035003=Campo : {0}
035004=Clase : {0} [Tabla : {1}, Estrategia de heredar : {2}]
035005=Campo : {0} [Tabla : {1}]

#
# Datastore Adapter
#
036000=El constructor {0}(ClassBaseTable,int) no existe
036001=Campos del tipo {0} no estan apoyados
036002=Puede usa {0} con un campo persistence-capable solamente
036003=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

#
# JDOQL Expressions
#
037000=No se puede navegar el campo "{0}" en "{1}". Debe hacer un Cast este Interface a un tipo concreto y intentarlo otra vez.
037001=Query tiene una referencia al campo "{0}", pero la tabla del Query "{1}" no tiene ninguna columna por este campo
037002=Query tiene una referencia al campo "{0}" pero el campo "{1}" no existe en el objeto del campo "{2}"
037003=Query tiene comparacion a un objeto "{0}" que no tiene identidad de JDO - quizas el objeto sea transient o embedded. Siempre devuelve nada.
037004=Query tiene comparacion con una collecion qu no es nulo. DataNucleus no lo apoya.

037005=Query tiene una referencia al campo "{0}" pero la clase usa "subclass-table" estrategia de heredar y no hay ninguna subclase de esa clase. No podemos crear un Query de JDOQL.
037006=Query tiene una referencia al campo "{0}" per la clase usa "subclass-table" estrategia de heredar. DataNucleus apoya una relacion 1-1 con "subclass-table" si hay una subclase sola, pero aqui hay mas! Vamos a usar "{1}"
037007=Intenta de comparar el "instanceof" de un objeto con una expressi�n de tipo "{0}". JDOQL solo permita la comparaci�n con una clase.

037008=Intenta de usar el m�todo "{0}" de la clase "{1}", pero el m�todo no es public static final. No lo apoyamos en JDOQL.
037009=Intenta de usar el m�todo "{0}" de la clase "{1}", �pero no lo existe!
037010=El operador de JDOQL "instanceof" tiene clase "{0}", pero no la encontramos. Por favor, compruebe que la clase esta puesta correctamente.

037011=Intenta de invocar la expresi�n "{0}" con un argumento que no es numerico. Esta expresi�n acepta solo argumentos de tipo numerico.
037012=Intenta de usar "DISTINCT" con la expresi�n "{0}". No es posible con esta funci�n.

037013=Query de JDOQL tiene una expresi�n para construir un objeto de la clase "{0}" con un constructor que no existe! Por favor, corrigelo.
037014=Intenta de crear un objeto nuevo usando un constructor con "{0}" valores pero necesita "{1}"
037015=Error en la creaci�n de un objeto nuevo de "{0}" : {1}

#
# OID
#
038000=El valor del OID no es valido : {0}
038001=Identidad "{0}" puesto a la clase {1}, pero el tipo de object-id no esta correcta.
038002=Valor generado para el campo "{0}" con estrategia="{1}" (Generador="{2}") : valor={3}
038003=Identidad generado para el campo {0}, id : {1} es incorrecto
038004=No hay ningun generador de valor para la estrategia "{0}" para este base de datos. Por favor, lee en la documentaci�n sobre las estrategias que esta apoyado para este base de datos.
038005=El campo "{0}" ha sido especificado usar un TableGenerator pero no hay uno con nombre "{1}"
038006=El campo "{0}" ha sido especificado usar un SequenceGenerator pero no hay uno con nombre "{1}"

#
# Value Generators
#
040000=Era imposible crear un generador de identidades de tipo "{0}" : {1}
040001=Creando instancia de ValueGenerator de tipo "{0}" para "{1}"

040002=El repositorio de IDs es invalido
040003=Hemos encontrado un error en la allocaci�n de un block de IDs : {0}
040004=Hemos reservado un bloque de {0} valores
040005=Creando repositorio de IDs en la base de datos ...
040006=El valor de "key-cache-size" ({0}) es invalido
040007=El valor de "sequence" ({0}) es invalido
040008=Hemos encontrado un error en la allocaci�n de IDs : {0}
040009=El generador "{0}" no genera valores num�ricos. Por favor llame a "next()" para obtener el valor como un Objeto.

#
# Mapping
#
041000=El tipo de Java {0} no tiene una clase disponible para convertirlo en DataNucleus.
041001=El campo "{0}" con tipo de Java {1} no tiene una clase disponible para convertirlo en DataNucleus.
041002=El camp "{0}" con tipo de Java {1} que es "embedded" no tiene una clase disponible para convertirlo en DataNucleus.
041003=El campo "{0}" es una Collecci�n o Mapa "embedded", pero DataNucleus no lo apoya.

041004=De alguna manera {0}.{1}() estaba llamado, pero debiera ser imposible
041005=De alguna manera {0}.{1}() del mapping del campo "{2}" estaba llamado, pero debiera ser imposible

041006=El Constructor ({0},{1}) no existe por el tipo de Mapping {2}
041007=El Constructor ({0},{1},{2}) no existe por el tipo de Mapping {3}
041009=La generaci�n del nuevo tipo de Mapping {0} ha fallada : {1}
041010=La generaci�n del nuevo tipo de Mapping {0} por la tabla {1}, field {2} ha fallada : {3}
041011=Constructor {0}(ClassTable, int) no existe

041012=Puede usa {0} con un campo persistence-capable solamente
041013=El fichero plugin.xml tiene una clase de datastore-mapping de "{0}" pero no la existe

041014=El campo "{0}" tiene "mapping-class" de "{1}" pero esa clase no existe! Por favor, compruebela y empezar de nuevo.

041015=No es posible fijar el campo a un objeto de otro PersistenceManager
041016=Objeto no es PersistenceCapable. Objeto clase = {0}, valor = {1}
041017=No es posible fijar la identidad de Application. Par�metro = {0}

041018=El objeto "{0}" tiene campo "{1}" con relacion bidireccional 1-1 a "{2}" pero el campo "{3}" de ese objeto no tiene valor; DataNucleus va a ponerlo en el objeto directamente.
041019=El objeto "{0}" tiene campo "{1}" con valor de "{2}" pero vamos a borrar ese objeto asi que ponemos nulo en el campo.
041020=El objeto "{0}" tiene campo "{1}" con relacion bidireccional 1-1 a "{2}" pero el campo de ese objeto tiene relacion a "{3}"!
041021=El objeto "{0}" tiene campo "{1}" con relacion bidirectional N-1 a "{2}" pero la collecci�n "{3}" no contiene este objeto; lo vamos a a�adir
041022=El objeto "{0}" tiene campo "{1}" con relacion bidirectional N-1 a "{2}" pero la collecci�n "{3}" no contiene este objeto.

041023=�El campo "{0}" no tiene MetaData por un contenedor (collection/map/array) !
041024=Error un la creaci�n de la clase "{0}" : {1}
041025=Es imposible usar un Query con un campo serializado ("{0}"). Usted tiene que cambiar el Query, o cambiar el campo para ser no serializado.

041026=Es imposible usar un Query con un campo de array almacenado en una columna("{0}"). Usted tiene que cambiar el Query, o cambiar el campo para ser no almacenado asi.

041027=No puede poner el parametro de BigInteger : valor = {0}
041028=No puede obtener el resultado de BigInteger : param = {0}
041029=No puede poner el parametro de BigDecimal : valor = {0}
041030=No puede obtener el resultado de BigDecimal : param = {0}

041031=No puede poner el parametro de Object : valor = {0}
041032=No puede obtener el resultado de Object : param = {0}

041033=No puede obtener el resultado de URL : param = {0}, valor = {1}

041034=Obtuvo objeto con OID "{0}"
041035=No era posible obtener el OID del objeto

041036=Error creating AID of type {0} : exception is {1}
041037=Error creating AID of type {0}, field {1}, value {2} : exception is {3}
041038=La columna de Primary Key "{0}" de la tabla "{1}" no esta designada
041039=�No podemos crear una identidad de SingleFieldIdentity porque la llave obtenido de la base de datos es nulo!

041040=El campo "{0}" esta serializado. DataNucleus no apoya la persistencia de campos de Interface como serializados.
041041=El campo "{0}" esta serializado. DataNucleus no apoya la persistencia de campos de Interface como "embedded".

041042=El campo "{0}" esta "embedded". DataNucleus no apoya la persistencia de campos de Object como "embedded".
041043=El campo "{0}" esta Object (non-serializado). DataNucleus no apoya la persistencia de campos de Object que no estan serializados.

041044=El campo "{0}" es de referencia (interface/Object) de tipo "{1}" pero DataNucleus no puede asignar el campo al valor de tipo "{2}". Solo puede asignar el campo a un valor especificado por el atributo "implementation-classes".

#
# Datastore Mapping
#
041045=resolveEntity({0}, {1})
041046=�Los mappings datastore est�n en el fichero "{0}", pero el fichero no existe!
041047=Los mappings datastore est�n en el fichero "{0}" pero hab�a un error leerlo : {1}
041048=La clase de mapping datastore "{0}" no est�. Por favor, compruebe la especificaci�n de clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
041049=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

#
# JDOQL
#
042000=No se puede usar Query con Extent de la clase {0}
042001=No hay una clase de candidato por el Query de JDOQL
042002=El filtro de Query de JDOQL "{0}" no da un resultado de boolean
042003=El orden de Query de JDOQL "{0}" contiene una expresi�n que no esta corecta
042004=El orden de Query de JDOQL "{0}" contiene una direcci�n que no esta corecta. Debe ser "ascending", "descending", "asc", "desc".
042005=El Query de JDOQL incluye un parametro "{0}"pero no hay una declaraci�n de este en la lista de parametros.
042006=El Query de JDOQL hace falta {0} parametros, pero hay solamente {1}
042007=Error usando Query de JDOQL "{0}" : {1}.
042009=El Query contiene la identificaci�n "{0}", pero este es una palabra clave de JDOQL. El Query no es valido.
042008=El query ("{0}") tiene operador de assignar ("=") pero no existe en JDOQL. �La intenci�n era usar el operador '==' para comparar dos objetos?

042010=JDOQL Single-String de "{0}"
042011=El Query contiene una palabra clave de JDOQL ("{0}") pero no esta en su debido posici�n. Usted puede poner las palabras claves en una orden definido en la especificaci�n de JDOQL.
042012=JDOQL Single-String Query tiene que empezar con SELECT
042013=JDOQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" despu�s.
042014=JDOQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
042015=JDOQL Single-String expects the keyword "{0}" after the keyword "{1}"
042016=JDOQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
042017=JDOQL Single-String Query tiena una clausula de subquery pero no cierre el parentesis

#
# JPQL
#
043000=JPQL Single-String de "{0}"
043001=El Query de JPQL contiene una palabra clave ("{0}") pero no esta en su debido posici�n. Usted puede poner las palabras claves en una orden definido en la especificaci�n de JPQL.
043002=JPQL Single-String Query tiene que empezar con SELECT/UPDATE/DELETE
043003=JPQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" despu�s.
043004=JPQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
043005=JPQL Single-String expects the keyword "{0}" after the keyword "{1}"
043006=JPQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
043007=JPQL UPDATE/DELETE query no puede tener una clausula de GROUP BY
043008=JPQL UPDATE/DELETE query no puede tener una clausula de HAVING
043009=JPQL UPDATE/DELETE query no puede tener una clausula de ORDER BY
043010=JPQL UPDATE Query no tiene una clausula de UPDATE! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"
043011=JPQL UPDATE Query tiene clausula de UPDATE pero no hay SET! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"

#
# MetaData
#
044001=MetaData para el campo/propiedad "{0}" tiene atributo "{1}" con valor "{2}" pero acepta "{3}"
044002=MetaData extension "{0}" acepta valores de "{1}" pero tiene valor de "{2}"!
044003=Campo/propiedad "{0}" tiene una collecci�n pero no hay ningun tipo de elemento en el MetaData ni es posible inferirlo por generics, usamos Object
044004=Campo/propiedad "{0}" tiene un mapa pero no hay ningun tipo de clave-valor en el MetaData ni es posible inferirlos por generics, usamos Object

044005=MetaData Management : Carga de Metadata de los archivos de metadata "{0}" ...
044006=MetaData Management : Carga de Metadata de las clases "{0}" ...
044007=MetaData Management : Carga de Metadata del persistence-unit "{0}" ...
044008=MetaData Management : Carga de Metadata del usuario ...
044009=MetaData Management : Carga de Metadata del jar "{0}" ...
044010=MetaData Management : Carga de Metadata ya ha terminado


044013=MetaData Management : Inicialisando con los archivos de MetaData y clases
044014=MetaData Management : Inicialisaci�n con los archivos de MetaData y clases ya ha terminado
044015=El archivo de MetaData "{0}" no contiene MetaData valido
044016=Hemos encontrado errores durante el proceso de leer los archivos de MetaData y clases. Compruebe por favor, las excepciones adjuntados
044017=La clase "{0}" no tiene MetaData o annotaciones.

044018=Populaci�n del MetaData ...
044019=Inicialisaci�n del MetaData ...
044020=Hemos encontrado errores durante la inicialisaci�n de MetaData. Compruebe por favor, las excepciones adjuntados

044021=MetaData Management : Inicialisando con el persistence-unit "{0}"
044022=MetaData Management : Inicialisation con el persistence-unit "{0}" ya ha terminado
044023=Hemos encontrado errores durante el proceso de leer el MetaData del persistence-unit "{0}". Compruebe por favor, las excepciones adjuntados

044026=Clase "{0}" descubierto para ser parte del persistence-unit "{1}"; cargandolo
044027=El Persistence-Unit "{0}" contiene una referencia a mapping-file "{1}" pero era imposible leerlo - {2}
044028=El plugin de MetaData handler "{0}" no existe en el CLASSPATH. Por favor compruebe el CLASSPATH y la especificai�n de plugin.
044029=Error creando handler del tipo "{0}" para analizar el MetaData : {1}
044030=Analizando el MetaData "{0}" con handler "{1}" (validar="{2}")

044031=�Intenta de analizar un archivo que era nulo!
044032=Error en abrir el archivo de Meta-Data "{0}"
044033=No puede leer Meta-Data input "{0}"

044034=Empezando a analizar el elemento "{0}" (profundidad="{1}")
044035=Terminando a analizar el elemento "{0}" (profundidad="{1}")
044036=El tag "{0}" no puede tener el tag padre "{1}" : debe ser {2}
044037=El tag es desconocido : "{0}"
044038=Error en el analizo del archivo "{0}" a la linea {1} : {2} - Por favor compruebe el DTD y la validad de este MetaData.
044039=Error en el analizo del archivo "{0}" a la linea {1}, columna {2} : {3} - Por favor compruebe el DTD y la validad de este MetaData.
044040=Error en el analizo del archivo "{0}" tiene causa {1}
044041=A value is expected in the attribute "{0}" for "{1}" in element "{2}". 

044042=Un error ha ocurrido durante el analisis de <"{0}"> dentro de "{1}" para el URI "{2}"

044043=Registrando la clase "{0}" no tener Meta-Data
044044=Deregistrando la clase "{0}" no tener Meta-Data - ya vamos a a�adir el Meta-Data
044045=El archivo "{0}" contiene metadata de tipo "{1}" pero debe contener del tipo "{2}". Vamos a ignorarlo
044046=No hemos encontrado ningun archivo "persistence.xml" en el CLASSPATH. Debes poner esos ficheros en la carpeta META-INF/ de los JARs.
044047=No hemos encontrado el Persistence-Unit "{0}" en los archivos "persistence.xml" disponibles.

044048=No hemos encontrado el MetaData del tipo "{0}" por la clase "{1}"
044049=No encontramos el MetaData del tipo "{0}" por la clase "{1}" en {2}
044050=No encontramos el MetaData por la query {0} en {1}
044051=No encontramos el MetaData por la secuencia {0} en {1}
044052=El MetaData del tipo "{0}" por la clase "{1}" sera {2}
044053=El MetaData por la query {0} sera {1}
044054=El MetaData por la secuencia {0} sera {1}
044055=El analizo del archivo de MetaData {0} fall�
044056=El archivo "{0}" va a tener su definici�n internal de MetaData aumentado con informaci�n de ORM MetaData
044057=The package name in empty in MetaData file {1}.
044058=The package {0} has an empty MetaData specified for a class name. Please check the file {1}.
044059=Encontro el Meta-Data de la clase {0} pero la clase no esta analizado! Por favor, debes analizar la clase antes de usar DataNucleus.
044060=A�adiendo el Meta-Data por el campo {0} de la clase {1} como no estaba en la definici�n de Meta-Data.
044061=El elemento de Meta-Data "class" por package {0} necesita un 'name' attributo.
044062=El campo "{0} en la clase {1} hemos hecho non-persistente como una propiedad de persistencia con el mismo nombre existe

044063=La clase "{0}" esta especificada como PersistenceCapable pero es Inner y no es estatico. Clases asi no pueden ser PersistenceCapable.

044064=La clase {0} va a usar "application identity" pero no hay "objectid-class" en la definici�n. DataNucleus va a usar to {1}
044065=La clase {0} va a usar "application identity", no hay "objectid-class" en la definici�n, pero hay {1} campos de primary-key. No podemos usar SingleFieldIdentity.
044066=La clase {0} va a usar "application-identity", no hay "objectid-class" y hay un campo de PK , pero el campo es de un tipo invalido {1} por SingleFieldIdentity. Puede usar los tipos short, Short, int, Integer, long, Long, byte, Byte, char, Character, o String.

044067=No hay un class loader especificado por cargar las classes del MetaData de class {0}. Usando el default ClassLoader.
044068=No puede popular la clase {0} como es populado
044069=El Meta-Data no ha sido inicializado por la clase {0}.
044070=El Meta-Data no ha sido populado por la clase {0}.
044071=�La clase {0} tiene campo {1} definido en el MetaData, pero este campo no existe en la clase!
044072=�La clase {0} tiene metodo {1} definido en el MetaData, pero este metodo no existe en la clase!
044073=�La clase {0} tiene propiedad {1} definido en el MetaData, pero el "getter" metodo no existe en la clase!
044074=�La clase {0} tiene propiedad {1} definido en el MetaData, pero el "setter" metodo no existe en la clase!

044075=Populating Meta-Data for class {0}.
044076=Initialising Meta-Data for class {0}.

044077=La clase {0} ha sido definido con el object-id class {1} pero no hay ningun campo como "primary key". Por favor debes anotar con el tag "primary-key" los campos usar como parte de la llave primaria
044078=Class {0} has been specified with {1} primary key fields, but this class is using {2} identity and should be application identity.

044079=La clase {0} ha sido definido con el object-id class {1}. La clase no existe. Por favor, compruebe el especficaci�n o CLASSPATH.
044080=La clase {0} tiene MetaData pero la clase no existe. Por favor compruebe la especificaci�n de CLASSPATH.
044081=La clase {0} ha sido definido con un persistence-capable-superclass {1} pero no existe.
044082=La clase {0} ha sido definido con un persistence-capable-superclass {1} que no es un superclass de esa clase.
044083=La clase {0} ha sido definido con un persistence-capable-superclass {1} que no es Persistence-Capable (no hay Meta-Data).
044087=The persistence-capable-superclass for class {0} must be class {1}, NOT class {2}.
044088=The persistence-capable-superclass {1} for class {0} cant be found. Please check your CLASSPATH specifications.
044089=DataNucleus ha puesto un valor de persistence-capable-superclass "{1}" por la clase "{0}"; no tenia valor en el MetaData.
044090=La clase {0} ya tiene un campo con el nombre {1}.

044099=La clase {0} tiene una estrategia de heredar de SUPERCLASS, pero no hay una superclase!
044091=La clase "{0}" no tiene un persistence-capable-superclass, pero tiene una superclase "{1}" que ES PersistenceCapable. Corrigalo por favor.

044093=El tipo de identidad en la clase "{0}" no es lo mismo que el tipo de identidad en la superclase.
044094=La estrategia de Datastore-identity en la clase "{0}" ("{1}") no es la misma que la estrategia de Datastore-Identity en la superclase ("{2}").

044095=La clase "{0}" va a tener su definici�n internal de MetaData aumentado con informaci�n de annotaciones
044096=La clase "{0}" va a tener su definici�n internal de MetaData aumentado con informaci�n de ORM MetaData
044097=La clase {0} tiene MetaData con implements {1} pero la clase no existe! Por favor compruebe el CLASSPATH y MetaData.
044098=La clase {0} tiene una estrategia de heredar de "{1}" pero apoyamos "{2}" solamente.
044099=La clase {0} tiene una estrategia de heredar de "superclass-table", pero no superclase existe o no existe con propia tabla
044100=La clase {0} tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene un discriminador.
044101=La clase {0} tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene una columna de discriminador
044102=La clase {0} tiene una estrategia de heredar usando la tabla de clase {1} con la columna de discriminador {2}. Esta clase no tiene un valor de discriminador
044103=La clase {0} usa la estrategia de discriminaci�n de "value-map" pero no tiene valor. Vamos a usar el nombre de la clase!

044104=La clase "{0}" tiene una estrategia de "{1}" pero DataNucleus no la apoya. Usamos el "default"

044105=No hay un cargador de clases definido para cargar las clases con el MetaData por campo "{0}" de clase "{1}". Va a usar el cargador de clases del sistema.
044106=No puede popular el campo "{0}" de la clase "{1}" con un campo nulo.
044107=No puede popular el campo "{0}" de la clase "{1}" no ya ha sido populado.
044108=No puede cambiar el campo "{0}" de la clase "{1}" porque ya ha sido inicializado.
044109=Error en el MetaData por el campo "{0}" de la clase "{1}" : es definido como {2} con "persistence-modifier={3}" pero tiene "default-fetch-group=true" o "primary-key=true" definido! Deben ser falsos.
044111=No podemos persistir el campo "{0}" de la clase {1} porque es de un tipo de array que DataNucleus no apoya. Por favor, debe cambiarlo por una colecci�n.
044112=El campo "{0}" ya existe en la clase "{1}", pero tiene otra definici�n.
044113=La clase "{0}" tiene campo "{1}" como de la clase "{2}" pero no hemos encontrado esta clase
044114=La clase "{0}" tiene campo "{1}" como de la clase "{2}" pero no es una superclase! Usted puede usar solamente los campos de las superclases que son PersistenceCapable.
044115=La clase "{0}" tiene campo "{2}" con "mapped-by" de "{2}". Este campo no existe en el otro lado de la relaci�n ("{3}")!!
044116=La clase "{0}" tiene campo "{1}" con "implementation-classes" pero la clase de implementaci�n "{2}" no existe!!
044117=Cannot populate the field "{0}" of the class "{1}" with a the value "{2}" for the property "{3}".

044118=Una columna tiene el jdbc-type de "{0}". Es invalido. El jdbc-type no existe en la lista de la clase java.sql.Types class, o DataNucleus no lo apoya.
044119=Una columna sin campo de la clase "{0}" ha sido especificado sin el nombre. Cualquier columna sin campo tiene que tener un nombre
044120=Una columna "{0}" sin campo de la clase "{1}" ha sido especificado sin el tipo de JDBC. Cualquier columna sin campo tiene que tener un tipo de JDBC

044121=El campo "{0}" tiene tipo "{1}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044122=El campo "{0}" es una collecci�n de elementos de tipo "{1}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044123=El campo "{0}" es una mapa con llaves de tipo "{1}" pero la llave es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044124=El campo "{0}" es una mapa con valores de tipo "{1}" pero el valor es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044125=A�adiendo el Meta-Data por el campo "{0}" de la clase "{1}" "embedded" en la clase "{2}" como no estaba en la definici�n de <embedded> Meta-Data.
044126=El campo "{0}" es una collecci�n de elementos de tipo "{1}" como "embedded". No hay ningun <join>. Usted necesita poner un <join>, porque los elementos van a estar almacenado alli.
044127=El campo "{0}" es una mapa de llaves de tipo "{1}" como "embedded". No hay ningun <join>. Usted necesita poner un <join>, porque las llaves van a estar almacenado alli.
044128=El campo "{0}" es una mapa de valores de tipo "{1}" como "embedded". No hay ningun <join>. Usted necesita poner un <join>, porque los valores van a estar almacenado alli.
044129=El campo "{0}" tiene como "embedded" un objeto de tipo "{1}", pero es "interface" y lo has especificado con un CAMPO "{2}". Debe ser una PROPIEDAD.
044130=El campo "{0}" tiene <join table="...">. El atributo "table" no tiene sentido cuando <join> esta dentro de <field>. En este caso usted debe poner "table" en <field>.
044131=El campo "{0}" de la clase "{1}" ha sido definido con <collection> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044132=El campo "{0}" de la clase "{1}" ha sido definido con el "collection" MetaData pero no es un campo de Collection.
044133=�El campo "{0}" de la clase "{1}" ha sido definido como Collection pero el tipo de elemento no ha sido definido!
044134=El campo "{0}" de la clase "{1}" ha sido definido como Collection con elementos de tipo {2}. �Este tipo de elemento no existe!
044135=El campo "{0}" de la clase "{1}" ha sido definido como Collection con elementos de tipo {2}. Este tipo ha sido resuelto a  {3}
044136=El campo "{0}" es una collecci�n de (non-serializado) elementos de tipo "{1}" pero no tiene ningun <join>. Para almacenar una collecci�n asi necesita una tabla de juntar, o marcarlo como "serialized".
044137=El campo "{0}" tiene mapped-by de <order> pero el campo ("{1}.{2}") no existe!
044138=El campo "{0}" tiene ordering con un campo ("{1}.{2}") que no existe!
044139=El campo "{0}" tiene ordering con una direcci�n invalida ("{1}"). Debe ser ASC o DESC
044140=El campo "{0}" de la clase "{1}" ha sido definido con <array> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044141=El campo "{0}" de la clase "{1}" ha sido definido con <array> MetaData pero no es un campo de array.
044142=El campo "{0}" es una matriz de (non-serializado) elementos de tipo "{1}" pero no tiene ningun <join>. Para almacenar una matriz asi necesita una tabla de juntar, o marcarlo como "serialized".
044143=El campo "{0}" de la clase "{1}" ha sido definido con <map> y key-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "key-implementation-classes" extension de DataNucleus.
044144=El campo "{0}" de la clase "{1}" ha sido definido con <map> y value-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "value-implementation-classes" extension de DataNucleus.
044145=El campo "{0}" de la clase "{1}" ha sido definido con "map" MetaData pero no es un campo de Map.
044146=�El campo "{0}" de la clase "{1}" ha sido definido como Map pero el tipo de key no ha sido definido!
044147=El campo "{0}" de la clase "{1}" ha sido definido como Map con keys del tipo {2}. �Este tipo de key no existe!
044148=El campo "{0}" de la clase "{1}" ha sido definido como Map con keys de tipo {2}. Este tipo de key ha sido resuelto a {3}.
044149=El campo "{0}" de la clase "{1}" ha sido definido como Map pero el tipo de value no ha sido definido!
044150=El campo "{0}" de la clase {1} ha sido definido como Map con values del tipo {2}. �Este tipo de value no existe!
044151=El campo "{0}" de la clase "{1}" ha sido definido como Map con values del tipo {2}. Este tipo de value ha sido resuelto a {3}.
044152=El campo "{0}" tiene key-type como "{1}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044153=El campo "{0}" tiene value-type como "{1}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044154=�Query no tiene un nombre ! Por favor, cada Query necesita un nombre.
044155=�Sequence no tiene un nombre ! Por favor, cada Sequence necesita un nombre.
044156=La estratagia no esta !
044157=La estratagia no esta !
044158=El factory-class {0} no esta !
044159=El factory-class {0} no hace javax.jdo.IdGenerator !
044160=La especificaci�n del tag de <extension> no esta correcta. El vendor-name ({0}), key ({1}) y value ({2}) deben ser especificados.
044161=El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) but no hay clases de implementaci�n de "{1}"

044200=La clase "{0}" tiene anotaciones de {1} y vamos a usarlas.
044201=La clase "{0}" tiene anotaci�n "{1}" con propiedad "{2}" pero es invalido. Por favor compruebe la especificaci�n para esta anotaci�n.
044202=La clase "{0}" tiene anotaciones pero no hay ning�n AnnotationReader registrado para este tipo de anotaciones. Por favor compruebe el CLASSPATH y las anotaciones para validez.
044203=La clase/el campo "{0}" tiene anotaci�n "{1}" que no era posible procesar

044204=@Index especificado por la clase "{0}" pero no hay campos/columnas asi que JPOX lo ignora
044205=@Unique especificado por la clase "{0}" pero no hay campos/columnas asi que JPOX lo ignora
044206=@ForeignKey especificado por la clase "{0}" pero no hay campos/columnas asi que JPOX lo ignora

044207=La clase "{0}" tiene especificaci�n de @FetchPlan y @FetchPlans. Usted debe poner solo una
044208=La clase "{0}" tiene especificaci�n de @FetchGroup y @FetchGroups. Usted debe poner solo una
044209=La clase "{0}" tiene especificaci�n de @Query y @Queries. Usted debe poner solo una
044210=La clase "{0}" tiene especificaci�n de @Join y @Joins. Usted debe poner solo una

#
# Query Result
#
052600=El resultado del Query ya esta cerrado
052601=Ha encontrado un error leyendo el ResultSet : {0}
052602=No hay m�s elementos en el resultado del Query
052603=No puede cambiar el ResultSet del Query
052604=No apoyamos esta operaci�n en el resultado de un Query
052605=Cerrar el resultado del Query da un error : {0}
052606=Leyendo los resultados del query "{0}" como la conneccion va a cerrar

#
# SQL
#
059000=No apoyamos borraci�n por Query de SQL/DataNucleusSQL.
059001=Tiene un Query de SQL que esta vacia. Es invalido
059002=El estatement de SQL ("{0}") no empieza con SELECT. Es invalido
059004=No se puede usar Extent de Candidatos con un Query de SQL.
059005=No se puede usar collecciones de Candidato con un Query de SQL.
059006=No se puede poner el resultado con un Query de SQL.
059007=No se puede poner el serie con un Query de SQL.
059008=No se puede poner un filtro con un Query de SQL.
059009=No se puede usar variables con un Query de SQL.
059010=SQL apoya grouping pero explicitamente como GROUP BY en el texto de SQL.
059011=SQL apoya ordering pero explicitamente como ORDER BY en el texto de SQL.
059012=Query de SQL : "{0}"
059016=No se puede usar parametros con un Query de SQL.
059025=Error con la ejecucion de Query de SQL "{0}".
059026=No se puede usarlos imports con un Query de SQL.
059028=SQL query "{0}" necesita {1} parametros pero no hay ninguno
059030=SQL query "{0}" necesita un parametro con nombre "{1}" pero no hay ninguno en el Map
